import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { generateStaticMapUrl as generateSecureStaticMapUrl } from './mapboxUtils';

interface GeoPosition {
  name: string;
  type: string;
  coordinates: [number, number];
  description?: string;
  Adresse?: string;
}

interface TripDetails {
  title: string;
  description?: string;
  startDate?: string;
  endDate?: string;
  category?: string;
  notes?: string;
  geopositions: GeoPosition[];
  ai_content?: string;
}

// Constants for styling
const STYLES = {
  colors: {
    primary: '#1d1d1e',
    secondary: '#62626a',
    accent: '#61936f',
    background: '#fcfcfc',
    link: '#3b82f6'
  },
  fonts: {
    title: 20,
    subtitle: 16,
    heading: 14,
    normal: 11,
    small: 9
  },
  spacing: {
    margin: 20,
    padding: 10,
    lineHeight: 7
  }
};

// Helper function to format dates
const formatDate = (date: string) => {
  return new Date(date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
};

// Helper function to clean text
const cleanText = (text: string) => {
  if (!text) return '';
  return text
    .replace(/^[Ø=Üí]+\s*/g, '')  // Remove the Ø=Üí prefix
    .replace(/[^\x20-\x7E]/g, '') // Remove non-printable characters
    .replace(/\s+/g, ' ')         // Normalize whitespace
    .replace(/[`*_~]/g, '')       // Remove markdown formatting characters
    .replace(/\[(.*?)\]\(.*?\)/g, '$1') // Convert markdown links to just text
    .replace(/!\[.*?\]\(.*?\)/g, '')    // Remove markdown images
    .replace(/\\[a-z]+\{.*?\}/g, '')    // Remove LaTeX expressions
    .replace(/\u{1F4CD}/gu, '')         // Remove the 📍 emoji
    .replace(/&[a-z]+;/g, '')           // Remove HTML entities
    .trim();
};

// Function to add a page header
const addPageHeader = (pdf: jsPDF, pageNumber: number, totalPages: number) => {
  const pageWidth = pdf.internal.pageSize.width;
  
  // Add top border
  pdf.setDrawColor(STYLES.colors.accent);
  pdf.setLineWidth(0.5);
  pdf.line(STYLES.spacing.margin, 10, pageWidth - STYLES.spacing.margin, 10);
  
  // Add page number
  pdf.setFontSize(STYLES.fonts.small);
  pdf.setTextColor(STYLES.colors.secondary);
  pdf.text(`Page ${pageNumber} of ${totalPages}`, pageWidth - STYLES.spacing.margin, 15, { align: 'right' });
  
  return 25; // Return starting Y position for content
};

// Function to add a page footer
const addPageFooter = (pdf: jsPDF) => {
  const pageWidth = pdf.internal.pageSize.width;
  const pageHeight = pdf.internal.pageSize.height;
  
  // Add bottom border
  pdf.setDrawColor(STYLES.colors.accent);
  pdf.setLineWidth(0.5);
  pdf.line(STYLES.spacing.margin, pageHeight - 15, pageWidth - STYLES.spacing.margin, pageHeight - 15);
  
  // Add footer text
  pdf.setFontSize(STYLES.fonts.small);
  pdf.setTextColor(STYLES.colors.secondary);
  const today = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
  pdf.text(`Generated by ZapAround on ${today}`, STYLES.spacing.margin, pageHeight - 10);
};

// Function to add section title
const addSectionTitle = (pdf: jsPDF, title: string, yPos: number) => {
  const pageWidth = pdf.internal.pageSize.width;
  
  pdf.setFillColor(STYLES.colors.background);
  pdf.setDrawColor(STYLES.colors.accent);
  pdf.setLineWidth(0.5);
  
  // Draw section background
  pdf.rect(
    STYLES.spacing.margin - 5,
    yPos - 5,
    pageWidth - (STYLES.spacing.margin * 2) + 10,
    12,
    'F'
  );
  
  // Add bottom border
  pdf.line(
    STYLES.spacing.margin - 5,
    yPos + 7,
    pageWidth - STYLES.spacing.margin + 5,
    yPos + 7
  );
  
  // Add title text
  pdf.setFontSize(STYLES.fonts.subtitle);
  pdf.setTextColor(STYLES.colors.primary);
  pdf.setFont('helvetica', 'bold');
  pdf.text(title, STYLES.spacing.margin, yPos + 4);
  
  return yPos + 15;
};

// Function to add the cover page
const addCoverPage = async (pdf: jsPDF, tripDetails: TripDetails) => {
  const pageWidth = pdf.internal.pageSize.width;
  const pageHeight = pdf.internal.pageSize.height;
  let yPos = 40;

  // Add logo
  const logoUrl = 'https://zaparound.com/logo.png';
  try {
    const logoImage = await fetch(logoUrl).then(res => res.blob());
    const logoImageUrl = URL.createObjectURL(logoImage);
    
    // Add logo with width of 60mm and maintain aspect ratio
    const logoWidth = 60;
    const logoHeight = 20;
    const logoX = (pageWidth - logoWidth) / 2;
    pdf.addImage(logoImageUrl, 'PNG', logoX, yPos, logoWidth, logoHeight);
    
    yPos += logoHeight + 20;
  } catch (error) {
    console.error('Failed to load logo:', error);
    // Fallback to text if logo fails to load
    pdf.setFontSize(32);
    pdf.setTextColor(STYLES.colors.primary);
    pdf.setFont('helvetica', 'bold');
    pdf.text('ZapAround', pageWidth / 2, yPos, { align: 'center' });
    yPos += 20;
  }
  
  // Add "Travel Itinerary" subtitle
  pdf.setFontSize(STYLES.fonts.subtitle);
  pdf.setTextColor(STYLES.colors.secondary);
  pdf.setFont('helvetica', 'normal');
  pdf.text('Travel Itinerary', pageWidth / 2, yPos, { align: 'center' });

  // Add trip title
  yPos += 40;
  pdf.setFontSize(24);
  pdf.setTextColor(STYLES.colors.primary);
  pdf.setFont('helvetica', 'bold');
  pdf.text(tripDetails.title, pageWidth / 2, yPos, { align: 'center' });

  // Add trip details
  if (tripDetails.description) {
    yPos += 20;
    pdf.setFontSize(STYLES.fonts.normal);
    pdf.setTextColor(STYLES.colors.secondary);
    pdf.setFont('helvetica', 'normal');
    const descriptionLines = pdf.splitTextToSize(
      tripDetails.description,
      pageWidth - (STYLES.spacing.margin * 4)
    );
    pdf.text(descriptionLines, pageWidth / 2, yPos, { align: 'center' });
  }

  // Add dates if available
  if (tripDetails.startDate || tripDetails.endDate) {
    yPos += 40;
    pdf.setFontSize(STYLES.fonts.normal);
    pdf.setTextColor(STYLES.colors.primary);
    pdf.setFont('helvetica', 'bold');
    
    const dateText = tripDetails.startDate && tripDetails.endDate
      ? `${formatDate(tripDetails.startDate)} - ${formatDate(tripDetails.endDate)}`
      : tripDetails.startDate
        ? formatDate(tripDetails.startDate)
        : formatDate(tripDetails.endDate!);
    
    pdf.text(dateText, pageWidth / 2, yPos, { align: 'center' });
  }

  // Add decorative element
  yPos = pageHeight - 80;
  pdf.setDrawColor(STYLES.colors.accent);
  pdf.setLineWidth(1);
  pdf.line(STYLES.spacing.margin, yPos, pageWidth - STYLES.spacing.margin, yPos);
};

// Function to add map page
const addMapPage = async (pdf: jsPDF, geopositions: GeoPosition[]) => {
  let yPos = addPageHeader(pdf, 2, pdf.internal.getNumberOfPages());
  
  // Add map title
  yPos = addSectionTitle(pdf, 'Trip Overview Map', yPos);
  yPos += 10;

  // Add static map
  const mapUrl = await generateStaticMapUrl(geopositions);
  const mapImage = await fetch(mapUrl).then(res => res.blob());
  const mapImageUrl = URL.createObjectURL(mapImage);
  const mapHeight = 120;
  
  pdf.addImage(
    mapImageUrl,
    'PNG',
    STYLES.spacing.margin,
    yPos,
    pdf.internal.pageSize.width - (STYLES.spacing.margin * 2),
    mapHeight
  );
  
  addPageFooter(pdf);
};

// Function to add stops pages
const addStopsPages = (pdf: jsPDF, geopositions: GeoPosition[]) => {
  let yPos = addPageHeader(pdf, pdf.internal.getCurrentPageInfo().pageNumber, pdf.internal.getNumberOfPages());
  
  // Add stops title
  yPos = addSectionTitle(pdf, 'Stops and Points', yPos);
  yPos += 10;

  const pageWidth = pdf.internal.pageSize.width;
  const contentWidth = pageWidth - (STYLES.spacing.margin * 2);
  const columnWidth = (contentWidth - 20) / 3; // 20mm total gap between columns
  const itemHeight = 45; // Height for each stop item
  const itemsPerPage = Math.floor((pdf.internal.pageSize.height - 70) / itemHeight);
  
  geopositions.forEach((pos, index) => {
    const column = index % 3;
    const row = Math.floor((index % (itemsPerPage * 3)) / 3);
    
    // Check if we need a new page
    if (index > 0 && index % (itemsPerPage * 3) === 0) {
      addPageFooter(pdf);
      pdf.addPage();
      yPos = addPageHeader(pdf, pdf.internal.getCurrentPageInfo().pageNumber, pdf.internal.getNumberOfPages());
      yPos = addSectionTitle(pdf, 'Stops and Points (Continued)', yPos);
      yPos += 10;
    }
    
    const xPos = STYLES.spacing.margin + (column * (columnWidth + 10));
    const currentYPos = yPos + (row * itemHeight);
    
    // Add stop box
    pdf.setFillColor(STYLES.colors.background);
    pdf.setDrawColor(STYLES.colors.accent);
    pdf.setLineWidth(0.2);
    pdf.roundedRect(xPos, currentYPos, columnWidth, itemHeight - 8, 2, 2, 'FD');
    
    // Add stop number and name
    pdf.setFontSize(STYLES.fonts.normal);
    pdf.setTextColor(STYLES.colors.primary);
    pdf.setFont('helvetica', 'bold');
    
    // Handle title
    const title = `${index + 1}. ${cleanText(pos.name)}`;
    const titleLines = pdf.splitTextToSize(title, columnWidth - 10);
    const titleHeight = titleLines.length > 1 ? 12 : 6;
    pdf.text(titleLines, xPos + 5, currentYPos + 6);
    
    // Add description if available
    let currentTextPos = currentYPos + titleHeight + 6;
    if (pos.description) {
      pdf.setTextColor(STYLES.colors.secondary);
      pdf.setFontSize(STYLES.fonts.small);
      pdf.setFont('helvetica', 'normal');
      const descLines = pdf.splitTextToSize(cleanText(pos.description), columnWidth - 10);
      if (descLines.length > 2) {
        descLines.length = 2;
        descLines[1] = descLines[1].substring(0, descLines[1].length - 3) + '...';
      }
      pdf.text(descLines, xPos + 5, currentTextPos);
      currentTextPos += (descLines.length * 5) + 2;
    }
    
    // Add address
    pdf.setTextColor(STYLES.colors.secondary);
    pdf.setFontSize(STYLES.fonts.small);
    pdf.setFont('helvetica', 'normal');
    
    // Format address
    const address = pos.Adresse ? cleanText(pos.Adresse) :
      `${pos.coordinates[1].toFixed(4)}, ${pos.coordinates[0].toFixed(4)}`;
    
    const addressLines = pdf.splitTextToSize(address, columnWidth - 10);
    if (addressLines.length > 2) {
      addressLines.length = 2;
      addressLines[1] = addressLines[1].substring(0, addressLines[1].length - 3) + '...';
    }
    pdf.text(addressLines, xPos + 5, currentTextPos);
  });
  
  addPageFooter(pdf);
};

// Function to add AI content pages
const addAIContentPages = (pdf: jsPDF, content: string) => {
  let yPos = addPageHeader(pdf, pdf.internal.getCurrentPageInfo().pageNumber, pdf.internal.getNumberOfPages());
  
  // Add AI content title
  yPos = addSectionTitle(pdf, 'Travel Tips & AI Insights', yPos);
  yPos += 10;

  const pageWidth = pdf.internal.pageSize.width;
  const contentWidth = pageWidth - (STYLES.spacing.margin * 2);
  
  // Split content into sections and clean markdown
  const sections = content
    .replace(/```[^`]*```/g, '') // Remove code blocks
    .split(/(?=# )/g);
  
  sections.forEach((section, index) => {
    if (index > 0) {
      // Add page break between major sections
      addPageFooter(pdf);
      pdf.addPage();
      yPos = addPageHeader(pdf, pdf.internal.getCurrentPageInfo().pageNumber, pdf.internal.getNumberOfPages());
    }
    
    // Process section content
    const lines = section.split('\n');
    lines.forEach((line) => {
      // Skip empty lines
      if (!line.trim()) return;
      
      // Check for page break
      if (yPos > pdf.internal.pageSize.height - 30) {
        addPageFooter(pdf);
        pdf.addPage();
        yPos = addPageHeader(pdf, pdf.internal.getCurrentPageInfo().pageNumber, pdf.internal.getNumberOfPages());
      }
      
      // Set text style based on heading level
      if (line.startsWith('# ')) {
        pdf.setFontSize(STYLES.fonts.title);
        pdf.setTextColor(STYLES.colors.primary);
        pdf.setFont('helvetica', 'bold');
        line = line.substring(2);
      } else if (line.startsWith('## ')) {
        pdf.setFontSize(STYLES.fonts.subtitle);
        pdf.setTextColor(STYLES.colors.primary);
        pdf.setFont('helvetica', 'bold');
        line = line.substring(3);
      } else if (line.startsWith('### ')) {
        pdf.setFontSize(STYLES.fonts.heading);
        pdf.setTextColor(STYLES.colors.primary);
        pdf.setFont('helvetica', 'bold');
        line = line.substring(4);
      } else {
        pdf.setFontSize(STYLES.fonts.normal);
        pdf.setTextColor(STYLES.colors.secondary);
        pdf.setFont('helvetica', 'normal');
      }
      
      // Clean and split text
      const textLines = pdf.splitTextToSize(cleanText(line), contentWidth);
      textLines.forEach((textLine: string) => {
        if (textLine.trim()) {
          pdf.text(textLine, STYLES.spacing.margin, yPos);
          yPos += STYLES.spacing.lineHeight;
        }
      });
      
      yPos += 3; // Add extra space between paragraphs
    });
  });
  
  addPageFooter(pdf);
};

const generateStaticMapUrl = async (geopositions: GeoPosition[]) => {
  try {
    // Create markers string
    const markers = geopositions.map((pos, index) => {
      return `pin-s-${index + 1}+1d1d1e(${pos.coordinates[0]},${pos.coordinates[1]})`;
    }).join(',');

    // Calculate bounds to center the map
    const lngs = geopositions.map(pos => pos.coordinates[0]);
    const lats = geopositions.map(pos => pos.coordinates[1]);
    const center: [number, number] = [
      (Math.min(...lngs) + Math.max(...lngs)) / 2,
      (Math.min(...lats) + Math.max(...lats)) / 2
    ];

    // Use secure token generation
    return await generateSecureStaticMapUrl(
      center,
      6, // zoom
      800, // width
      400, // height
      'mapbox://styles/mapbox/streets-v11',
      markers
    );
  } catch (err) {
    console.error('Error generating static map URL:', err);
    // Return a fallback URL or empty string
    return '';
  }
};

const generateGoogleMapsUrl = (geopositions: GeoPosition[]) => {
  if (geopositions.length === 0) return '';
  
  const origin = geopositions[0];
  const destination = geopositions[geopositions.length - 1];
  const waypoints = geopositions.slice(1, -1);
  
  let url = 'https://www.google.com/maps/dir/?api=1';
  url += `&origin=${origin.coordinates[1]},${origin.coordinates[0]}`;
  url += `&destination=${destination.coordinates[1]},${destination.coordinates[0]}`;
  
  if (waypoints.length > 0) {
    const waypointsStr = waypoints
      .map(wp => `${wp.coordinates[1]},${wp.coordinates[0]}`)
      .join('|');
    url += `&waypoints=${waypointsStr}`;
  }
  
  url += '&travelmode=driving';
  return url;
};

export const generateTripPDF = async (tripDetails: TripDetails) => {
  // Create PDF document
  const pdf = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4'
  });

  // Add cover page
  await addCoverPage(pdf, tripDetails);

  // Add map page
  if (tripDetails.geopositions.length > 0) {
    pdf.addPage();
    await addMapPage(pdf, tripDetails.geopositions);
  }

  // Add stops pages
  if (tripDetails.geopositions.length > 0) {
    pdf.addPage();
    addStopsPages(pdf, tripDetails.geopositions);
  }

  // Add AI content pages
  if (tripDetails.ai_content) {
    pdf.addPage();
    addAIContentPages(pdf, tripDetails.ai_content);
  }

  // Add navigation link
  if (tripDetails.geopositions.length > 0) {
    pdf.addPage();
    let yPos = addPageHeader(pdf, pdf.internal.getCurrentPageInfo().pageNumber, pdf.internal.getNumberOfPages());
    
    yPos = addSectionTitle(pdf, 'Navigation', yPos);
    yPos += 20;
    
    const googleMapsUrl = generateGoogleMapsUrl(tripDetails.geopositions);
    pdf.setTextColor(STYLES.colors.link);
    pdf.setFontSize(STYLES.fonts.normal);
    pdf.setFont('helvetica', 'normal');
    pdf.textWithLink('Open Route in Google Maps', STYLES.spacing.margin, yPos, { url: googleMapsUrl });
    
    addPageFooter(pdf);
  }

  // Save the PDF
  pdf.save(`zaparound-trip-${tripDetails.title.toLowerCase().replace(/\s+/g, '-')}.pdf`);
}; 