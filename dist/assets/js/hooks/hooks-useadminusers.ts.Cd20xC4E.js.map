{"version":3,"file":"hooks-useadminusers.ts.Cd20xC4E.js","sources":["../../../../src/hooks/useAdminUsers.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useToast } from '@/components/ui/use-toast';\nimport { useTranslation } from 'react-i18next';\nimport { userCache, getOrSetCache } from '@/utils/cache';\nimport { UserData, UserRole } from '@/types/user';\n\n// Define a type for the data returned from the RPC function\ninterface UserRoleData {\n  user_id: string;\n  role: string;\n}\n\nconst USERS_PER_PAGE = 20;\n\nexport function useAdminUsers() {\n  const [users, setUsers] = useState<UserData[]>([]);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [currentPage, setCurrentPage] = useState(1);\n  const { toast } = useToast();\n  const { t } = useTranslation('common');\n\n  const fetchUsers = async () => {\n    try {\n      setIsLoading(true);\n      \n      return await getOrSetCache(\n        userCache,\n        'admin-users',\n        async () => {\n          // First, check if we're an admin to avoid permission issues\n          const { data: isAdminData, error: isAdminError } = await supabase.rpc('is_admin');\n          \n          if (isAdminError) {\n            console.error('Error checking admin status:', isAdminError);\n            throw isAdminError;\n          }\n          \n          if (!isAdminData) {\n            console.error('User is not an admin');\n            throw new Error('Unauthorized: User is not an admin');\n          }\n          \n          // Get all users from Auth system using the admin API\n          const { data: authResponse, error: authError } = await supabase.functions.invoke('admin-get-users', {\n            body: {}\n          });\n          \n          if (authError) {\n            console.error('Error fetching auth users:', authError);\n            throw authError;\n          }\n          \n          const authUsers = authResponse.users || [];\n          \n          if (authUsers.length === 0) {\n            console.error('No auth users returned');\n            return [];\n          }\n          \n          // Get profile data to supplement auth data\n          const { data: profilesData, error: profilesError } = await supabase\n            .from('profiles')\n            .select(`\n              id,\n              username,\n              full_name\n            `);\n          \n          if (profilesError) {\n            console.error('Error fetching profiles:', profilesError);\n            // Continue anyway, we'll just have less profile data\n          }\n          \n          // Create a map of profile data by user ID for easy lookup\n          const profileMap: Record<string, { username?: string; full_name?: string | null }> = {};\n          if (profilesData) {\n            profilesData.forEach(profile => {\n              profileMap[profile.id] = {\n                username: profile.username,\n                full_name: profile.full_name\n              };\n            });\n          }\n          \n          // Get all user roles using our RPC function\n          const { data: rolesData, error: rolesError } = await supabase\n            .rpc('get_all_user_roles') as { data: UserRoleData[] | null, error: any };\n          \n          if (rolesError) {\n            console.error('Error fetching user roles:', rolesError);\n            throw rolesError;\n          }\n          \n          // Get post counts (blogs) for each user\n          const { data: blogData, error: blogError } = await supabase\n            .from('blogs')\n            .select('author_id');\n          \n          if (blogError) {\n            console.error('Error fetching blog counts:', blogError);\n            // We'll continue anyway, just with zero posts for everyone\n          }\n          \n          // Transform blog data to get count by author\n          const authorCounts: Record<string, number> = {};\n          if (blogData) {\n            blogData.forEach(blog => {\n              authorCounts[blog.author_id] = (authorCounts[blog.author_id] || 0) + 1;\n            });\n          }\n\n          // Get trip counts for each user\n          const { data: tripsData, error: tripsError } = await supabase\n            .from('trips')\n            .select('user_id, trip_type')\n            .eq('trip_type', 'ZapTrip');\n\n          const { data: zapOutData, error: zapOutError } = await supabase\n            .from('zapout_data')\n            .select('user_id');\n\n          const { data: zapRoadData, error: zapRoadError } = await supabase\n            .from('zaproad_data')\n            .select('user_id');\n\n          // Calculate trip counts\n          const tripCounts: Record<string, { zap_trip: number; zap_out: number; zap_road: number }> = {};\n          \n          if (tripsData) {\n            tripsData.forEach(trip => {\n              if (!tripCounts[trip.user_id]) {\n                tripCounts[trip.user_id] = { zap_trip: 0, zap_out: 0, zap_road: 0 };\n              }\n              tripCounts[trip.user_id].zap_trip++;\n            });\n          }\n          \n          if (zapOutData) {\n            zapOutData.forEach(trip => {\n              if (!tripCounts[trip.user_id]) {\n                tripCounts[trip.user_id] = { zap_trip: 0, zap_out: 0, zap_road: 0 };\n              }\n              tripCounts[trip.user_id].zap_out++;\n            });\n          }\n          \n          if (zapRoadData) {\n            zapRoadData.forEach(trip => {\n              if (!tripCounts[trip.user_id]) {\n                tripCounts[trip.user_id] = { zap_trip: 0, zap_out: 0, zap_road: 0 };\n              }\n              tripCounts[trip.user_id].zap_road++;\n            });\n          }\n          \n          // Combine all data\n          const combinedData: UserData[] = authUsers.map(authUser => {\n            const userId = authUser.id;\n            const profile = profileMap[userId] || {};\n            const userRole = rolesData?.find((r) => r.user_id === userId);\n            const postCount = authorCounts[userId] || 0;\n            const tripCount = tripCounts[userId] || { zap_trip: 0, zap_out: 0, zap_road: 0 };\n            \n            // Make sure we're using a valid enum value for the role\n            let role: UserRole = 'nosubs';\n            if (userRole && (\n              userRole.role === 'admin' || \n              userRole.role === 'nosubs' || \n              userRole.role === 'tier1' || \n              userRole.role === 'tier2' || \n              userRole.role === 'tier3' || \n              userRole.role === 'tier4' || \n              userRole.role === 'enterprise'\n            )) {\n              role = userRole.role as UserRole;\n            }\n            \n            return {\n              id: userId,\n              email: authUser.email || userId,\n              full_name: profile.full_name || null,\n              username: profile.username || authUser.email?.split('@')[0] || 'user',\n              role: role,\n              post_count: postCount,\n              zap_trip_count: tripCount.zap_trip,\n              zap_out_count: tripCount.zap_out,\n              zap_road_count: tripCount.zap_road,\n              created_at: authUser.created_at\n            };\n          });\n          \n          return combinedData;\n        },\n        { ttl: 1000 * 60 * 5 } // 5 minutes TTL\n      );\n    } catch (error) {\n      console.error('Exception when fetching data:', error);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const refreshUsers = async () => {\n    try {\n      const users = await getOrSetCache(\n        userCache,\n        'admin-users',\n        () => fetchUsers(),\n        { force: true }\n      );\n      setUsers(users);\n    } catch (error) {\n      console.error('Error refreshing users:', error);\n      toast({\n        title: t('toasts.error'),\n        description: t('toasts.fetchError'),\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  useEffect(() => {\n    fetchUsers().then(setUsers).catch(error => {\n      console.error('Error in useEffect:', error);\n      toast({\n        title: t('toasts.error'),\n        description: t('toasts.fetchError'),\n        variant: \"destructive\",\n      });\n    });\n  }, []);\n\n  // Filter users based on search term\n  const filteredUsers = users.filter(user => \n    user.email.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    (user.full_name && user.full_name.toLowerCase().includes(searchTerm.toLowerCase())) ||\n    user.username.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  // Calculate pagination\n  const totalPages = Math.ceil(filteredUsers.length / USERS_PER_PAGE);\n  const paginatedUsers = filteredUsers.slice(\n    (currentPage - 1) * USERS_PER_PAGE,\n    currentPage * USERS_PER_PAGE\n  );\n\n  // Reset to first page when search term changes\n  useEffect(() => {\n    setCurrentPage(1);\n  }, [searchTerm]);\n\n  return {\n    users: paginatedUsers,\n    allUsers: users,\n    filteredCount: filteredUsers.length,\n    loading: isLoading,\n    searchTerm,\n    setSearchTerm,\n    refreshUsers,\n    pagination: {\n      currentPage,\n      totalPages,\n      setCurrentPage,\n      hasNextPage: currentPage < totalPages,\n      hasPreviousPage: currentPage > 1,\n      startIndex: (currentPage - 1) * USERS_PER_PAGE + 1,\n      endIndex: Math.min(currentPage * USERS_PER_PAGE, filteredUsers.length)\n    }\n  };\n}\n"],"names":["useAdminUsers","users","setUsers","useState","searchTerm","setSearchTerm","isLoading","setIsLoading","currentPage","setCurrentPage","toast","useToast","t","useTranslation","fetchUsers","async","getOrSetCache","userCache","data","isAdminData","error","isAdminError","supabase","rpc","Error","authResponse","authError","functions","invoke","body","authUsers","length","profilesData","profilesError","from","select","profileMap","forEach","profile","id","username","full_name","rolesData","rolesError","blogData","blogError","authorCounts","blog","author_id","tripsData","tripsError","eq","zapOutData","zapOutError","zapRoadData","zapRoadError","tripCounts","trip","user_id","zap_trip","zap_out","zap_road","map","authUser","userId","userRole","find","r","postCount","tripCount","role","email","split","post_count","zap_trip_count","zap_out_count","zap_road_count","created_at","ttl","useEffect","then","catch","title","description","variant","filteredUsers","filter","user","toLowerCase","includes","totalPages","Math","ceil","paginatedUsers","slice","allUsers","filteredCount","loading","refreshUsers","force","pagination","hasNextPage","hasPreviousPage","startIndex","endIndex","min"],"mappings":"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"}