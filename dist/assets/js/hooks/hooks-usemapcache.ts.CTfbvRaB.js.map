{"version":3,"file":"hooks-usemapcache.ts.CTfbvRaB.js","sources":["../../../../src/hooks/useMapCache.ts"],"sourcesContent":["import { useRef, useCallback, useEffect } from 'react';\nimport mapboxgl from 'mapbox-gl';\n\ninterface MapCacheOptions {\n  container: HTMLElement | null;\n  style: string;\n  center: [number, number];\n  zoom: number;\n  pitch?: number;\n  bearing?: number;\n  showTerrain?: boolean;\n  isMobile?: boolean;\n}\n\ninterface CachedMapInstance {\n  map: mapboxgl.Map;\n  style: string;\n  isInitialized: boolean;\n  markers: mapboxgl.Marker[];\n  sources: string[];\n  layers: string[];\n}\n\nexport const useMapCache = () => {\n  const mapCache = useRef<Map<string, CachedMapInstance>>(new Map());\n  const currentMapKey = useRef<string>('');\n\n  // Generate a cache key based on map configuration\n  const getMapKey = useCallback((options: MapCacheOptions): string => {\n    return `${options.style}-${options.showTerrain ? 'terrain' : 'no-terrain'}-${options.isMobile ? 'mobile' : 'desktop'}`;\n  }, []);\n\n  // Initialize or retrieve cached map\n  const getOrCreateMap = useCallback((options: MapCacheOptions): mapboxgl.Map | null => {\n    if (!options.container) return null;\n\n    const mapKey = getMapKey(options);\n    currentMapKey.current = mapKey;\n\n    // Check if we have a cached map with the same configuration\n    const cached = mapCache.current.get(mapKey);\n    \n    if (cached && cached.map && !cached.map._removed) {\n      // Reuse existing map\n      console.log('Reusing cached map instance:', mapKey);\n      \n      // Update container if needed\n      if (cached.map.getContainer() !== options.container) {\n        cached.map.getContainer().removeChild(cached.map.getCanvas());\n        options.container.appendChild(cached.map.getCanvas());\n      }\n      \n      // Update view if needed\n      const currentCenter = cached.map.getCenter();\n      const currentZoom = cached.map.getZoom();\n      \n      if (currentCenter.lng !== options.center[0] || \n          currentCenter.lat !== options.center[1] || \n          Math.abs(currentZoom - options.zoom) > 0.1) {\n        cached.map.setCenter(options.center);\n        cached.map.setZoom(options.zoom);\n        if (options.pitch !== undefined) cached.map.setPitch(options.pitch);\n        if (options.bearing !== undefined) cached.map.setBearing(options.bearing);\n      }\n      \n      return cached.map;\n    }\n\n    // Create new map instance\n    console.log('Creating new map instance:', mapKey);\n    \n    // Set access token\n    mapboxgl.accessToken = 'pk.eyJ1IjoibWlzdGVyZnJhenoiLCJhIjoiY203M2ZnM3BoMDhpMTJqcTNiYWpkamIzNyJ9.2SlcuEPIL2yCJw5TIPunVQ';\n\n    const map = new mapboxgl.Map({\n      container: options.container,\n      style: options.style,\n      center: options.center,\n      zoom: options.zoom,\n      pitch: options.pitch || 60,\n      bearing: options.bearing || 0,\n      attributionControl: false,\n      // Performance optimizations\n      preserveDrawingBuffer: false,\n      antialias: false,\n      fadeDuration: 0,\n      crossSourceCollisions: false,\n    });\n\n    // Initialize map with controls and layers\n    const initializeMap = async () => {\n      await new Promise<void>((resolve) => {\n        const onStyleLoad = () => {\n          // Remove existing controls to prevent duplicates\n          const existingControls = document.querySelectorAll('.mapboxgl-ctrl-group, .mapboxgl-ctrl-attrib');\n          existingControls.forEach(control => control.remove());\n\n          // Add navigation controls\n          const navControl = new mapboxgl.NavigationControl({ \n            showCompass: !options.isMobile,\n            visualizePitch: !options.isMobile\n          });\n          map.addControl(navControl, 'top-right');\n          map.addControl(new mapboxgl.FullscreenControl(), 'top-right');\n          map.addControl(\n            new mapboxgl.AttributionControl({\n              compact: true,\n            }),\n            'bottom-right'\n          );\n\n          // Add terrain and 3D layers only if enabled and not already added\n          if (options.showTerrain) {\n            addTerrainLayers(map);\n          }\n\n          // Add route source\n          if (!map.getSource('route')) {\n            map.addSource('route', {\n              'type': 'geojson',\n              'data': {\n                'type': 'Feature',\n                'properties': {},\n                'geometry': {\n                  'type': 'LineString',\n                  'coordinates': []\n                }\n              }\n            });\n          }\n\n          map.off('style.load', onStyleLoad);\n          resolve();\n        };\n\n        map.on('style.load', onStyleLoad);\n      });\n    };\n\n    // Store in cache\n    const cachedInstance: CachedMapInstance = {\n      map,\n      style: options.style,\n      isInitialized: false,\n      markers: [],\n      sources: ['route'],\n      layers: []\n    };\n\n    mapCache.current.set(mapKey, cachedInstance);\n\n    // Initialize the map\n    initializeMap().then(() => {\n      cachedInstance.isInitialized = true;\n    });\n\n    return map;\n  }, [getMapKey]);\n\n  // Add terrain layers to map\n  const addTerrainLayers = useCallback((map: mapboxgl.Map) => {\n    if (!map.getSource('mapbox-dem')) {\n      map.addSource('mapbox-dem', {\n        'type': 'raster-dem',\n        'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',\n        'tileSize': 512,\n        'maxzoom': 14\n      });\n\n      map.setTerrain({ \n        'source': 'mapbox-dem',\n        'exaggeration': 1.5 \n      });\n    }\n\n    if (!map.getLayer('sky')) {\n      map.addLayer({\n        'id': 'sky',\n        'type': 'sky',\n        'paint': {\n          'sky-type': 'atmosphere',\n          'sky-atmosphere-sun': [0.0, 90.0],\n          'sky-atmosphere-sun-intensity': 15\n        }\n      });\n    }\n\n    // Only add water and building layers for non-satellite styles\n    const currentStyle = map.getStyle().name || '';\n    if (!currentStyle.includes('satellite')) {\n      if (!map.getLayer('water') && map.getSource('mapbox')) {\n        map.addLayer({\n          'id': 'water',\n          'source': 'mapbox',\n          'source-layer': 'water',\n          'type': 'fill',\n          'paint': {\n            'fill-color': '#93c5fd',\n            'fill-opacity': 0.8\n          }\n        });\n      }\n\n      if (!map.getLayer('building') && map.getSource('mapbox')) {\n        map.addLayer({\n          'id': 'building',\n          'source': 'mapbox',\n          'source-layer': 'building',\n          'type': 'fill-extrusion',\n          'paint': {\n            'fill-extrusion-color': '#9ca3af',\n            'fill-extrusion-height': ['get', 'height'],\n            'fill-extrusion-base': ['get', 'min_height'],\n            'fill-extrusion-opacity': 0.6\n          }\n        });\n      }\n    }\n  }, []);\n\n  // Cache markers for reuse\n  const cacheMarkers = useCallback((markers: mapboxgl.Marker[]) => {\n    const currentCached = mapCache.current.get(currentMapKey.current);\n    if (currentCached) {\n      // Clear old markers\n      currentCached.markers.forEach(marker => marker.remove());\n      currentCached.markers = markers;\n    }\n  }, []);\n\n  // Update map style efficiently\n  const updateMapStyle = useCallback((newStyle: string) => {\n    const currentCached = mapCache.current.get(currentMapKey.current);\n    if (currentCached && currentCached.map && currentCached.style !== newStyle) {\n      console.log('Updating map style from', currentCached.style, 'to', newStyle);\n      currentCached.map.setStyle(newStyle);\n      currentCached.style = newStyle;\n      currentCached.isInitialized = false;\n      \n      // Re-initialize after style change\n      currentCached.map.once('style.load', () => {\n        currentCached.isInitialized = true;\n      });\n    }\n  }, []);\n\n  // Clear cache for a specific key or all\n  const clearCache = useCallback((key?: string) => {\n    if (key) {\n      const cached = mapCache.current.get(key);\n      if (cached) {\n        cached.markers.forEach(marker => marker.remove());\n        if (cached.map && !cached.map._removed) {\n          cached.map.remove();\n        }\n        mapCache.current.delete(key);\n      }\n    } else {\n      // Clear all cache\n      mapCache.current.forEach((cached) => {\n        cached.markers.forEach(marker => marker.remove());\n        if (cached.map && !cached.map._removed) {\n          cached.map.remove();\n        }\n      });\n      mapCache.current.clear();\n    }\n  }, []);\n\n  // Get cache statistics\n  const getCacheStats = useCallback(() => {\n    return {\n      size: mapCache.current.size,\n      keys: Array.from(mapCache.current.keys()),\n      currentKey: currentMapKey.current\n    };\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      clearCache();\n    };\n  }, [clearCache]);\n\n  return {\n    getOrCreateMap,\n    cacheMarkers,\n    updateMapStyle,\n    clearCache,\n    getCacheStats,\n    addTerrainLayers\n  };\n}; "],"names":["useMapCache","mapCache","useRef","Map","currentMapKey","getMapKey","useCallback","options","style","showTerrain","isMobile","getOrCreateMap","container","mapKey","current","cached","get","map","_removed","getContainer","removeChild","getCanvas","appendChild","currentCenter","getCenter","currentZoom","getZoom","lng","center","lat","Math","abs","zoom","setCenter","setZoom","pitch","setPitch","bearing","setBearing","mapboxgl","accessToken","attributionControl","preserveDrawingBuffer","antialias","fadeDuration","crossSourceCollisions","cachedInstance","isInitialized","markers","sources","layers","set","async","Promise","resolve","onStyleLoad","document","querySelectorAll","forEach","control","remove","navControl","NavigationControl","showCompass","visualizePitch","addControl","FullscreenControl","AttributionControl","compact","addTerrainLayers","getSource","addSource","type","data","properties","geometry","coordinates","off","on","initializeMap","then","url","tileSize","maxzoom","setTerrain","source","exaggeration","getLayer","addLayer","id","paint","getStyle","name","includes","cacheMarkers","currentCached","marker","updateMapStyle","newStyle","setStyle","once","clearCache","key","delete","clear","getCacheStats","size","keys","Array","from","currentKey","useEffect"],"mappings":"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"}