{"version":3,"file":"hooks-usemapdata.ts.F4WF97GX.js","sources":["../../../../src/hooks/useMapData.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { tripCache, getOrSetCache, cacheEventManager, CACHE_EVENTS } from '@/utils/cache';\nimport { useToast } from '@/hooks/use-toast';\n\nexport interface MapTripData {\n  id: string;\n  title: string;\n  type: 'zapout' | 'zaproad' | 'zaptrip';\n  coordinates: [number, number] | null;\n  location: string | null;\n  description?: string | null;\n  created_at: string;\n  updated_at?: string;\n  // ZapRoad specific fields\n  starting_city?: string | null;\n  starting_city_coordinates?: string | null;\n  end_city?: string | null;\n  end_city_coordinates?: string | null;\n}\n\nexport interface MapFavoriteData {\n  id: number;\n  place_id: string;\n  place_name: string;\n  place_address: string;\n  place_rating: number;\n  place_lat: number;\n  place_lng: number;\n  place_types: string[];\n  created_at: string;\n}\n\ninterface MapData {\n  trips: MapTripData[];\n  favorites: MapFavoriteData[];\n  lastUpdated: number;\n}\n\n// Utility function to parse coordinates\nconst parseCoordinates = (coordsData: any): [number, number] | null => {\n  if (!coordsData) return null;\n  \n  try {\n    // Case 1: Already an array\n    if (Array.isArray(coordsData) && coordsData.length === 2) {\n      const [lng, lat] = coordsData;\n      if (typeof lng === 'number' && typeof lat === 'number') {\n        return [lng, lat];\n      }\n    }\n    \n    // Case 2: JSON string of an array\n    if (typeof coordsData === 'string') {\n      try {\n        const parsed = JSON.parse(coordsData);\n        if (Array.isArray(parsed) && parsed.length === 2) {\n          const [lng, lat] = parsed;\n          if (typeof lng === 'number' && typeof lat === 'number') {\n            return [lng, lat];\n          }\n        }\n      } catch {\n        // Not a valid JSON, try other formats\n      }\n      \n      // Case 3: String format \"lat, lng\" (e.g., \"46.8144, -71.2082\")\n      if (coordsData.includes(',')) {\n        const parts = coordsData.split(',').map(part => parseFloat(part.trim()));\n        if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {\n          // Convert from lat,lng to lng,lat for Mapbox\n          return [parts[1], parts[0]];\n        }\n      }\n    }\n    \n    return null;\n  } catch (e) {\n    console.error('Error parsing coordinates:', e, coordsData);\n    return null;\n  }\n};\n\nexport function useMapData() {\n  const [mapData, setMapData] = useState<MapData>({\n    trips: [],\n    favorites: [],\n    lastUpdated: 0\n  });\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const { toast } = useToast();\n  const refreshTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Fetch all map data with caching\n  const fetchMapData = useCallback(async (forceRefresh = false) => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) throw new Error('No user found');\n\n      const cacheKey = `map-data-${user.id}`;\n      \n      const data = await getOrSetCache(\n        tripCache,\n        cacheKey,\n        async () => {\n          console.log('Fetching fresh map data from server...');\n          \n          // Fetch all trip types in parallel\n          const [zapoutResponse, zaproadResponse, zaptripResponse, favoritesResponse] = await Promise.all([\n            supabase\n              .from('zapout_data')\n              .select('id, title, description, coordinates, location, created_at, updated_at')\n              .eq('user_id', user.id)\n              .order('created_at', { ascending: false }),\n            \n            supabase\n              .from('zaproad_data')\n              .select('id, title, description, starting_city_coordinates, starting_city, end_city, end_city_coordinates, created_at, updated_at')\n              .eq('user_id', user.id)\n              .order('created_at', { ascending: false }),\n            \n            supabase\n              .from('trips')\n              .select('id, title, description, coordinates, location, created_at, updated_at')\n              .eq('user_id', user.id)\n              .order('created_at', { ascending: false }),\n\n            supabase\n              .from('favorites')\n              .select('*')\n              .eq('user_id', user.id)\n              .order('created_at', { ascending: false })\n          ]);\n\n          // Check for errors\n          if (zapoutResponse.error) throw zapoutResponse.error;\n          if (zaproadResponse.error) throw zaproadResponse.error;\n          if (zaptripResponse.error) throw zaptripResponse.error;\n          if (favoritesResponse.error) throw favoritesResponse.error;\n\n          // Process trip data\n          const trips: MapTripData[] = [\n            ...(zapoutResponse.data || []).map(trip => ({\n              ...trip,\n              type: 'zapout' as const,\n              coordinates: parseCoordinates(trip.coordinates)\n            })),\n            ...(zaproadResponse.data || []).map(trip => ({\n              ...trip,\n              type: 'zaproad' as const,\n              coordinates: parseCoordinates(trip.end_city_coordinates || trip.starting_city_coordinates),\n              location: trip.end_city || trip.starting_city,\n              starting_city: trip.starting_city,\n              starting_city_coordinates: trip.starting_city_coordinates,\n              end_city: trip.end_city,\n              end_city_coordinates: trip.end_city_coordinates\n            })),\n            ...(zaptripResponse.data || []).map(trip => ({\n              ...trip,\n              type: 'zaptrip' as const,\n              coordinates: parseCoordinates(trip.coordinates)\n            }))\n          ];\n\n          const result = {\n            trips,\n            favorites: favoritesResponse.data || [],\n            lastUpdated: Date.now()\n          };\n\n          console.log('Map data fetched successfully:', result);\n          return result;\n        },\n        { ttl: 1000 * 60 * 5, force: forceRefresh }\n      );\n\n      setMapData(data);\n      return data;\n    } catch (err: any) {\n      console.error('Error fetching map data:', err);\n      setError(err.message || 'Failed to fetch map data');\n      toast({\n        title: 'Error',\n        description: 'Failed to load map data. Please try again.',\n        variant: 'destructive',\n      });\n      return mapData;\n    } finally {\n      setLoading(false);\n    }\n  }, [mapData, toast]);\n\n  // Fetch incremental data (for real-time updates)\n  const fetchIncrementalData = useCallback(async () => {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) throw new Error('No user found');\n\n      const cacheKey = `map-data-${user.id}`;\n      \n      // Fetch fresh data from server\n      const [zapoutResponse, zaproadResponse, zaptripResponse, favoritesResponse] = await Promise.all([\n        supabase\n          .from('zapout_data')\n          .select('id, title, description, coordinates, location, created_at, updated_at')\n          .eq('user_id', user.id)\n          .order('created_at', { ascending: false }),\n        \n        supabase\n          .from('zaproad_data')\n          .select('id, title, description, starting_city_coordinates, starting_city, end_city, end_city_coordinates, created_at, updated_at')\n          .eq('user_id', user.id)\n          .order('created_at', { ascending: false }),\n        \n        supabase\n          .from('trips')\n          .select('id, title, description, coordinates, location, created_at, updated_at')\n          .eq('user_id', user.id)\n          .order('created_at', { ascending: false }),\n\n        supabase\n          .from('favorites')\n          .select('*')\n          .eq('user_id', user.id)\n          .order('created_at', { ascending: false })\n      ]);\n\n      // Check for errors\n      if (zapoutResponse.error) throw zapoutResponse.error;\n      if (zaproadResponse.error) throw zaproadResponse.error;\n      if (zaptripResponse.error) throw zaptripResponse.error;\n      if (favoritesResponse.error) throw favoritesResponse.error;\n\n      // Process new trip data\n      const newTrips: MapTripData[] = [\n        ...(zapoutResponse.data || []).map(trip => ({\n          ...trip,\n          type: 'zapout' as const,\n          coordinates: parseCoordinates(trip.coordinates)\n        })),\n        ...(zaproadResponse.data || []).map(trip => ({\n          ...trip,\n          type: 'zaproad' as const,\n          coordinates: parseCoordinates(trip.end_city_coordinates || trip.starting_city_coordinates),\n          location: trip.end_city || trip.starting_city,\n          starting_city: trip.starting_city,\n          starting_city_coordinates: trip.starting_city_coordinates,\n          end_city: trip.end_city,\n          end_city_coordinates: trip.end_city_coordinates\n        })),\n        ...(zaptripResponse.data || []).map(trip => ({\n          ...trip,\n          type: 'zaptrip' as const,\n          coordinates: parseCoordinates(trip.coordinates)\n        }))\n      ];\n\n      // Merge new data with existing data\n      const updatedTrips = [...mapData.trips];\n      const updatedFavorites = [...mapData.favorites];\n\n      // Update existing trips or add new ones\n      newTrips.forEach(newTrip => {\n        const existingIndex = updatedTrips.findIndex(trip => trip.id === newTrip.id);\n        if (existingIndex >= 0) {\n          updatedTrips[existingIndex] = newTrip;\n        } else {\n          updatedTrips.unshift(newTrip); // Add new trips at the beginning\n        }\n      });\n\n      // Add new favorites\n      (favoritesResponse.data || []).forEach(newFavorite => {\n        const existingIndex = updatedFavorites.findIndex(fav => fav.id === newFavorite.id);\n        if (existingIndex === -1) {\n          updatedFavorites.unshift(newFavorite);\n        }\n      });\n\n      const updatedData = {\n        trips: updatedTrips,\n        favorites: updatedFavorites,\n        lastUpdated: Date.now()\n      };\n\n      // Update cache\n      tripCache.set(cacheKey, updatedData, { ttl: 1000 * 60 * 5 });\n      setMapData(updatedData);\n\n      return updatedData;\n    } catch (err) {\n      console.error('Error fetching incremental data:', err);\n      // Fall back to full refresh on error\n      return fetchMapData(true);\n    }\n  }, [mapData, fetchMapData]);\n\n  // Invalidate cache when new trip is created\n  const invalidateCache = useCallback(async () => {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (user) {\n        const cacheKey = `map-data-${user.id}`;\n        tripCache.delete(cacheKey);\n        console.log('Map data cache invalidated');\n      }\n    } catch (err) {\n      console.error('Error invalidating cache:', err);\n    }\n  }, []);\n\n  // Remove trip from cache\n  const removeTripFromCache = useCallback((tripId: string) => {\n    setMapData(prev => ({\n      ...prev,\n      trips: prev.trips.filter(trip => trip.id !== tripId)\n    }));\n  }, []);\n\n  // Remove favorite from cache\n  const removeFavoriteFromCache = useCallback((favoriteId: number) => {\n    setMapData(prev => ({\n      ...prev,\n      favorites: prev.favorites.filter(fav => fav.id !== favoriteId)\n    }));\n  }, []);\n\n  // Debounced refresh function to prevent multiple rapid refreshes\n  const debouncedRefresh = useCallback(() => {\n    if (refreshTimeoutRef.current) {\n      clearTimeout(refreshTimeoutRef.current);\n    }\n    \n    refreshTimeoutRef.current = setTimeout(() => {\n      console.log('Debounced refresh triggered');\n      fetchMapData(true);\n    }, 100); // 100ms debounce\n  }, [fetchMapData]);\n\n  // Listen for cache invalidation events\n  useEffect(() => {\n    const unsubscribeTripCreated = cacheEventManager.subscribe(CACHE_EVENTS.TRIP_CREATED, () => {\n      console.log('Trip created event received, refreshing map data...');\n      debouncedRefresh();\n    });\n\n    const unsubscribeMapDataInvalidated = cacheEventManager.subscribe(CACHE_EVENTS.MAP_DATA_INVALIDATED, () => {\n      console.log('Map data invalidated event received, refreshing map data...');\n      debouncedRefresh();\n    });\n\n    const unsubscribeFavoritesInvalidated = cacheEventManager.subscribe(CACHE_EVENTS.FAVORITES_INVALIDATED, () => {\n      console.log('Favorites invalidated event received, refreshing map data...');\n      debouncedRefresh();\n    });\n\n    const unsubscribeFavoriteAdded = cacheEventManager.subscribe(CACHE_EVENTS.FAVORITE_ADDED, () => {\n      console.log('Favorite added event received, refreshing map data...');\n      debouncedRefresh();\n    });\n\n    const unsubscribeFavoriteRemoved = cacheEventManager.subscribe(CACHE_EVENTS.FAVORITE_REMOVED, () => {\n      console.log('Favorite removed event received, refreshing map data...');\n      debouncedRefresh();\n    });\n\n    // Cleanup subscriptions and timeout\n    return () => {\n      unsubscribeTripCreated();\n      unsubscribeMapDataInvalidated();\n      unsubscribeFavoritesInvalidated();\n      unsubscribeFavoriteAdded();\n      unsubscribeFavoriteRemoved();\n      if (refreshTimeoutRef.current) {\n        clearTimeout(refreshTimeoutRef.current);\n      }\n    };\n  }, [debouncedRefresh]);\n\n  // Initialize data on mount\n  useEffect(() => {\n    fetchMapData();\n  }, [fetchMapData]);\n\n  return {\n    mapData,\n    loading,\n    error,\n    fetchMapData,\n    fetchIncrementalData,\n    invalidateCache,\n    removeTripFromCache,\n    removeFavoriteFromCache,\n    refreshData: () => fetchMapData(true)\n  };\n} "],"names":["parseCoordinates","coordsData","Array","isArray","length","lng","lat","parsed","JSON","parse","includes","parts","split","map","part","parseFloat","trim","isNaN","e","useMapData","mapData","setMapData","useState","trips","favorites","lastUpdated","loading","setLoading","error","setError","toast","useToast","refreshTimeoutRef","useRef","fetchMapData","useCallback","async","forceRefresh","data","user","supabase","auth","getUser","Error","cacheKey","id","getOrSetCache","tripCache","zapoutResponse","zaproadResponse","zaptripResponse","favoritesResponse","Promise","all","from","select","eq","order","ascending","trip","type","coordinates","end_city_coordinates","starting_city_coordinates","location","end_city","starting_city","Date","now","ttl","force","err","message","title","description","variant","fetchIncrementalData","newTrips","updatedTrips","updatedFavorites","forEach","newTrip","existingIndex","findIndex","unshift","newFavorite","fav","updatedData","set","invalidateCache","delete","removeTripFromCache","tripId","prev","filter","removeFavoriteFromCache","favoriteId","debouncedRefresh","current","clearTimeout","setTimeout","useEffect","unsubscribeTripCreated","cacheEventManager","subscribe","CACHE_EVENTS","TRIP_CREATED","unsubscribeMapDataInvalidated","MAP_DATA_INVALIDATED","unsubscribeFavoritesInvalidated","FAVORITES_INVALIDATED","unsubscribeFavoriteAdded","FAVORITE_ADDED","unsubscribeFavoriteRemoved","FAVORITE_REMOVED","refreshData"],"mappings":"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"}