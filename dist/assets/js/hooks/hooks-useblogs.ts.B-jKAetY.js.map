{"version":3,"file":"hooks-useblogs.ts.B-jKAetY.js","sources":["../../../../src/hooks/useBlogs.ts","../../../../src/services/blogService.ts"],"sourcesContent":["import { useQuery } from '@tanstack/react-query';\nimport { useToast } from '@/components/ui/use-toast';\nimport { getBlogs, getBlogBySlug, getBlogsByCategory } from '@/services/blogService';\nimport { blogCache, getOrSetCache } from '@/utils/cache';\nimport { CACHE_TIME, STALE_TIME, getLocalizedContent } from '@/utils/blogUtils';\nimport { Blog } from '@/types/blog';\n\n// Re-export necessary types and functions to maintain API compatibility\nexport type { Blog };\nexport { getLocalizedContent };\n\n// Hook to fetch all blogs with pagination\nexport const useBlogs = (page = 1, limit = 9, language = 'en') => {\n  const { toast } = useToast();\n  \n  return useQuery({\n    queryKey: ['blogs', page, limit, language],\n    queryFn: async () => {\n      try {\n        console.log('useBlogs - Fetching blogs for language:', language, 'page:', page, 'limit:', limit);\n        \n        // Use our new cache implementation\n        const result = await getOrSetCache(\n          blogCache,\n          `blogs-${language}-${page}-${limit}`,\n          async () => {\n            console.log('useBlogs - Fetching from API');\n            const data = await getBlogs(page, limit);\n            console.log('useBlogs - API response:', data);\n            if (data.error) {\n              throw data.error;\n            }\n            return data;\n          },\n          { ttl: STALE_TIME }\n        );\n        \n        console.log('useBlogs - Final result:', result);\n        \n        // If blogs array is empty but no error, it might be a valid empty state\n        if (result.blogs.length === 0) {\n          console.log('useBlogs - No blogs found, but no error occurred');\n        }\n        \n        return result;\n      } catch (error: any) {\n        console.error('Error in useBlogs:', error);\n        const errorMessage = error?.message || 'Unknown error occurred';\n        const errorDetails = error?.details || '';\n        console.error('Error details:', { message: errorMessage, details: errorDetails });\n        \n        // Check if it's a 406 error\n        if (error?.code === '406' || error?.message?.includes('406') || \n            error?.details?.code === '406' || error?.details?.message?.includes('406')) {\n          console.error('406 Not Acceptable error detected in hook');\n          toast({\n            title: \"API Compatibility Issue\",\n            description: \"There's a compatibility issue with the blog service. Our team has been notified.\",\n            variant: \"destructive\",\n          });\n        } else {\n          toast({\n            title: \"Error loading blog posts\",\n            description: \"Please try again later. If the problem persists, contact support.\",\n            variant: \"destructive\",\n          });\n        }\n        \n        throw error;\n      }\n    },\n    staleTime: STALE_TIME,\n    gcTime: CACHE_TIME,\n    refetchOnWindowFocus: false,\n    retry: 3,\n  });\n};\n\n// Create a placeholder blog for not found cases\nconst createNotFoundBlog = (): Blog => {\n  const now = new Date().toISOString();\n  return {\n    id: 'not-found',\n    title_en: 'Blog Not Found',\n    title_fr: 'Blog Non Trouvé',\n    title_es: 'Blog No Encontrado',\n    content_en: 'The blog post you are looking for could not be found.',\n    content_fr: 'L\\'article de blog que vous recherchez est introuvable.',\n    content_es: 'La entrada de blog que estás buscando no se pudo encontrar.',\n    excerpt_en: 'Not found',\n    excerpt_fr: 'Non trouvé',\n    excerpt_es: 'No encontrado',\n    image_url: null,\n    author_id: 'system',\n    category: null,\n    created_at: now,\n    updated_at: now,\n    published_at: null,\n    parent_id: null,\n    notFound: true\n  } as Blog;\n};\n\n// Hook to fetch a single blog by ID\nexport const useBlogById = (blogSlug: string) => {\n  const { toast } = useToast();\n  \n  return useQuery({\n    queryKey: ['blog', blogSlug],\n    queryFn: async () => {\n      try {\n        console.log('Fetching blog with slug:', blogSlug);\n        const result = await getBlogBySlug(blogSlug);\n        console.log('Blog fetched successfully:', result);\n        \n        // If no blog was found, handle it gracefully\n        if (result === null) {\n          console.log('No blog found with slug:', blogSlug);\n          toast({\n            title: \"Blog not found\",\n            description: \"The blog post you're looking for doesn't exist or has been removed.\",\n            variant: \"destructive\",\n          });\n          \n          // Return a placeholder blog object to avoid errors in the UI\n          return createNotFoundBlog();\n        }\n        \n        return result;\n      } catch (error: any) {\n        console.error('Error in useBlogById:', error);\n        const errorMessage = error?.message || 'Unknown error occurred';\n        const errorDetails = error?.details || '';\n        console.error('Error details:', { message: errorMessage, details: errorDetails });\n        \n        // Check if it's a PGRST116 error (no rows returned)\n        if (error?.code === 'PGRST116' || \n            error?.message?.includes('JSON object requested, multiple (or no) rows returned') ||\n            error?.details?.code === 'PGRST116' || \n            error?.details?.message?.includes('JSON object requested, multiple (or no) rows returned')) {\n          console.error('PGRST116 error detected in hook - No blog found');\n          toast({\n            title: \"Blog not found\",\n            description: \"The blog post you're looking for doesn't exist or has been removed.\",\n            variant: \"destructive\",\n          });\n          \n          // Return a placeholder blog object to avoid errors in the UI\n          return createNotFoundBlog();\n        }\n        \n        // Check if it's a 406 error\n        if (error?.code === '406' || error?.message?.includes('406') || \n            error?.details?.code === '406' || error?.details?.message?.includes('406')) {\n          console.error('406 Not Acceptable error detected in hook');\n          toast({\n            title: \"API Compatibility Issue\",\n            description: \"There's a compatibility issue with the blog service. Our team has been notified.\",\n            variant: \"destructive\",\n          });\n        } else {\n          toast({\n            title: \"Error loading blog post\",\n            description: \"Please try again later. If the problem persists, contact support.\",\n            variant: \"destructive\",\n          });\n        }\n        \n        throw error;\n      }\n    },\n    staleTime: STALE_TIME,\n    gcTime: CACHE_TIME,\n    refetchOnWindowFocus: false,\n    enabled: !!blogSlug,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 10000)\n  });\n};\n\ninterface UseBlogsByCategoryOptions {\n  enabled?: boolean;\n  staleTime?: number;\n  gcTime?: number;\n  [key: string]: any;\n}\n\n// Hook to fetch blogs by category with pagination\nexport const useBlogsByCategory = (\n  category: string, \n  page = 1, \n  limit = 9, \n  options: UseBlogsByCategoryOptions = {}\n) => {\n  const { toast } = useToast();\n  \n  // Extract enabled from options to handle it properly\n  const { enabled, ...otherOptions } = options;\n  const isEnabled = enabled !== undefined ? Boolean(enabled) : Boolean(category && category.trim() !== '');\n  \n  return useQuery({\n    queryKey: ['blogs', 'category', category, page, limit],\n    queryFn: async () => {\n      if (!category || category === '') {\n        return { blogs: [], count: 0, totalPages: 0 };\n      }\n      \n      try {\n        console.log('useBlogsByCategory - Fetching blogs for category:', category, 'page:', page, 'limit:', limit);\n        \n        // Use our new cache implementation\n        const result = await getOrSetCache(\n          blogCache,\n          `blogs-category-${category}-${page}-${limit}`,\n          async () => {\n            console.log('useBlogsByCategory - Fetching from API');\n            const data = await getBlogsByCategory(category, page, limit);\n            console.log('useBlogsByCategory - API response:', data);\n            if (data.error) {\n              throw data.error;\n            }\n            return data;\n          },\n          { ttl: STALE_TIME }\n        );\n        \n        console.log('useBlogsByCategory - Final result:', result);\n        \n        return result;\n      } catch (error: any) {\n        console.error('Error in useBlogsByCategory:', error);\n        const errorMessage = error?.message || 'Unknown error occurred';\n        const errorDetails = error?.details || '';\n        console.error('Error details:', { message: errorMessage, details: errorDetails });\n        \n        toast({\n          title: \"Error loading blog posts\",\n          description: \"Please try again later. If the problem persists, contact support.\",\n          variant: \"destructive\",\n        });\n        \n        throw error;\n      }\n    },\n    staleTime: STALE_TIME,\n    gcTime: CACHE_TIME,\n    refetchOnWindowFocus: false,\n    retry: 2,\n    enabled: isEnabled,\n    ...otherOptions\n  });\n};\n","import { supabase } from '@/integrations/supabase/client';\nimport { Blog } from '@/types/blog';\nimport { createSlug } from '@/utils/blogUtils';\n\n// Get all blogs with pagination\nexport async function getBlogs(page = 1, limit = 10) {\n  const start = (page - 1) * limit;\n  const end = start + limit - 1;\n  \n  try {\n    console.log('Fetching blogs from Supabase, range:', start, end);\n    \n    // Use fetch directly to handle the 406 error case\n    const { data, error, count } = await supabase\n      .from('blogs')\n      .select('*', { count: 'exact' })\n      .eq('is_published', true) // Only get published blogs\n      .order('published_at', { ascending: false })\n      .range(start, end);\n      \n    if (error) {\n      console.error('Supabase error fetching blogs:', error);\n      \n      // Check if it's a 406 error\n      if (error.code === '406' || error.message?.includes('406')) {\n        console.error('406 Not Acceptable error - API content negotiation issue');\n        \n        // Try a fallback approach with minimal query\n        const fallbackResult = await supabase\n          .from('blogs')\n          .select('id, title_en, created_at')\n          .eq('is_published', true) // Only get published blogs\n          .limit(limit);\n          \n        if (!fallbackResult.error && fallbackResult.data) {\n          console.log('Fallback query succeeded with minimal fields');\n          return { \n            blogs: fallbackResult.data || [], \n            count: fallbackResult.data.length,\n            totalPages: 1\n          };\n        }\n      }\n      \n      throw {\n        message: 'Failed to fetch blog posts',\n        details: error,\n        supabaseError: true\n      };\n    }\n    \n    console.log(`Successfully fetched ${data?.length || 0} blogs`);\n    \n    // Cache the successful response\n    try {\n      localStorage.setItem('blogs-cache', JSON.stringify({ \n        blogs: data || [], \n        count: count || 0,\n        totalPages: Math.ceil((count || 0) / limit),\n        timestamp: Date.now()\n      }));\n    } catch (cacheError) {\n      console.error('Error caching blogs:', cacheError);\n    }\n    \n    return { \n      blogs: data || [], \n      count: count || 0,\n      totalPages: Math.ceil((count || 0) / limit)\n    };\n  } catch (error) {\n    console.error('Error in getBlogs function:', error);\n    // Check if we have cached blogs in localStorage as fallback\n    try {\n      const cachedBlogs = localStorage.getItem('blogs-cache');\n      if (cachedBlogs) {\n        console.log('Using cached blogs as fallback');\n        const parsed = JSON.parse(cachedBlogs);\n        \n        // Check if cache is not too old (less than 1 hour)\n        if (parsed.timestamp && (Date.now() - parsed.timestamp < 3600000)) {\n          return parsed;\n        } else {\n          console.log('Cache is too old, not using it');\n        }\n      }\n    } catch (cacheError) {\n      console.error('Error accessing cache:', cacheError);\n    }\n    \n    // If all else fails, return empty blogs array\n    return { \n      blogs: [], \n      count: 0,\n      totalPages: 0,\n      error: error\n    };\n  }\n}\n\n// Get a single blog by ID or slug\nexport async function getBlogBySlug(slug: string): Promise<Blog | null> {\n  if (!slug || typeof slug !== 'string') {\n    console.error('Invalid slug provided:', slug);\n    return null;\n  }\n\n  // Normalize the slug to improve matching\n  const normalizedSlug = slug.trim().toLowerCase();\n  \n  try {\n    console.log('Fetching blog with slug:', normalizedSlug);\n    \n    // First get all blogs\n    const { data: allBlogs, error: allBlogsError } = await supabase\n      .from('blogs')\n      .select('*')\n      .eq('is_published', true); // Only get published blogs\n      \n    console.log('Total published blogs found:', allBlogs?.length || 0);\n    if (allBlogs && allBlogs.length > 0) {\n      console.log('Sample blog titles:', allBlogs.slice(0, 3).map(b => ({ id: b.id, title: b.title_en, slug: b.slug })));\n    }\n      \n    if (allBlogsError) {\n      console.error(\"Error fetching all blogs:\", allBlogsError);\n      throw {\n        message: 'Failed to fetch blog posts',\n        details: allBlogsError,\n        supabaseError: true\n      };\n    }\n    \n    if (allBlogs && allBlogs.length > 0) {\n      // First try to find by exact ID match (UUID)\n      const blogById = allBlogs.find(blog => blog.id === normalizedSlug);\n      if (blogById) {\n        console.log('Blog found by ID:', blogById.id);\n        return blogById as Blog;\n      }\n      \n      // If not found by ID, try to match against a slug created from title_en\n      const blogBySlug = allBlogs.find(blog => {\n        if (!blog.title_en) return false;\n        \n        // Create a slug from the title using the same function as BlogCard\n        const blogSlug = createSlug(blog.title_en);\n        \n        console.log(`Comparing slug \"${blogSlug}\" with \"${normalizedSlug}\" for blog \"${blog.title_en}\"`);\n        \n        return blogSlug === normalizedSlug;\n      });\n      \n      if (blogBySlug) {\n        console.log('Blog found by title slug:', blogBySlug.id);\n        \n        // Cache the blog for offline access\n        try {\n          const cacheKey = `blog-${normalizedSlug}`;\n          localStorage.setItem(cacheKey, JSON.stringify({\n            blog: blogBySlug,\n            timestamp: Date.now()\n          }));\n        } catch (cacheError) {\n          console.error('Error caching blog:', cacheError);\n        }\n        \n        return blogBySlug as Blog;\n      }\n      \n      // If still not found, try partial matching\n      const blogByPartialTitle = allBlogs.find(blog => {\n        if (!blog.title_en) return false;\n        \n        return blog.title_en.toLowerCase().includes(normalizedSlug.replace(/-/g, ' '));\n      });\n      \n      if (blogByPartialTitle) {\n        console.log('Blog found by partial title match:', blogByPartialTitle.id);\n        return blogByPartialTitle as Blog;\n      }\n    }\n    \n    // If we get here, no blog was found\n    console.log('No blog found with slug:', normalizedSlug);\n    return null;\n    \n  } catch (error: any) {\n    console.error('Error in getBlogBySlug function:', error);\n    \n    // Check for PGRST116 error (no rows returned)\n    if (error.details?.code === 'PGRST116' || \n        error.details?.message?.includes('JSON object requested, multiple (or no) rows returned') ||\n        error.message?.includes('JSON object requested, multiple (or no) rows returned')) {\n      console.log('No blog found with slug (PGRST116):', normalizedSlug);\n      return null;\n    }\n    \n    // Try to get from cache if available\n    try {\n      const cacheKey = `blog-${normalizedSlug}`;\n      const cachedBlog = localStorage.getItem(cacheKey);\n      if (cachedBlog) {\n        console.log('Using cached blog as fallback');\n        const parsed = JSON.parse(cachedBlog);\n        \n        // Check if cache is not too old (less than 1 hour)\n        if (parsed.timestamp && (Date.now() - parsed.timestamp < 3600000)) {\n          return parsed.blog;\n        } else {\n          console.log('Cache is too old, not using it');\n        }\n      }\n    } catch (cacheError) {\n      console.error('Error accessing cache:', cacheError);\n    }\n    \n    throw error;\n  }\n}\n\n// Get blogs by category\nexport async function getBlogsByCategory(category: string, page = 1, limit = 10) {\n  if (!category || typeof category !== 'string') {\n    console.error('Invalid category provided:', category);\n    return { \n      blogs: [], \n      count: 0,\n      totalPages: 0,\n      error: 'Invalid category'\n    };\n  }\n\n  const start = (page - 1) * limit;\n  const end = start + limit - 1;\n  \n  // Normalize the category to improve matching\n  const normalizedCategory = category.trim().toLowerCase();\n  const cacheKey = `blogs-category-${normalizedCategory}-page-${page}-limit-${limit}`;\n  \n  try {\n    console.log(`Fetching blogs for category: ${normalizedCategory}, page: ${page}, limit: ${limit}`);\n    \n    const { data, error, count } = await supabase\n      .from('blogs')\n      .select('*', { count: 'exact' })\n      .ilike('category', `%${normalizedCategory}%`)\n      .order('published_at', { ascending: false })\n      .range(start, end);\n      \n    if (error) {\n      console.error('Error fetching blogs by category:', error);\n      \n      // Check if it's a 406 error\n      if (error.code === '406' || error.message?.includes('406')) {\n        console.error('406 Not Acceptable error - API content negotiation issue');\n        \n        // Try a fallback approach with minimal query\n        const fallbackResult = await supabase\n          .from('blogs')\n          .select('id, title_en, created_at, category')\n          .ilike('category', `%${normalizedCategory}%`)\n          .limit(limit);\n          \n        if (!fallbackResult.error && fallbackResult.data) {\n          console.log('Fallback query succeeded with minimal fields');\n          \n          // Cache the successful response\n          try {\n            localStorage.setItem(cacheKey, JSON.stringify({ \n              blogs: fallbackResult.data, \n              count: fallbackResult.data.length,\n              totalPages: 1,\n              timestamp: Date.now()\n            }));\n          } catch (cacheError) {\n            console.error('Error caching blogs by category:', cacheError);\n          }\n          \n          return { \n            blogs: fallbackResult.data, \n            count: fallbackResult.data.length,\n            totalPages: 1\n          };\n        }\n      }\n      \n      throw error;\n    }\n    \n    const result = { \n      blogs: data || [], \n      count: count || 0,\n      totalPages: Math.ceil((count || 0) / limit)\n    };\n    \n    // Cache the successful response\n    try {\n      localStorage.setItem(cacheKey, JSON.stringify({ \n        ...result,\n        timestamp: Date.now()\n      }));\n    } catch (cacheError) {\n      console.error('Error caching blogs by category:', cacheError);\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Error in getBlogsByCategory:', error);\n    \n    // Try to get from cache if available\n    try {\n      const cachedBlogs = localStorage.getItem(cacheKey);\n      if (cachedBlogs) {\n        console.log('Using cached blogs by category as fallback');\n        const parsed = JSON.parse(cachedBlogs);\n        \n        // Check if cache is not too old (less than 1 hour)\n        if (parsed.timestamp && (Date.now() - parsed.timestamp < 3600000)) {\n          return parsed;\n        } else {\n          console.log('Cache is too old, not using it');\n        }\n      }\n    } catch (cacheError) {\n      console.error('Error accessing cache:', cacheError);\n    }\n    \n    return { \n      blogs: [], \n      count: 0,\n      totalPages: 0,\n      error: error\n    };\n  }\n}\n\n// Create a new blog post - Fix for author_id being required\nexport async function createBlog(blog: Partial<Blog>) {\n  // Ensure author_id is present\n  if (!blog.author_id) {\n    throw new Error(\"author_id is required to create a blog post\");\n  }\n  \n  // Create a new object with just the required and provided fields\n  const blogToInsert = {\n    author_id: blog.author_id,\n    title_en: blog.title_en || '',\n    content_en: blog.content_en,\n    excerpt_en: blog.excerpt_en,\n    category: blog.category,\n    image_url: blog.image_url,\n    title_fr: blog.title_fr,\n    content_fr: blog.content_fr,\n    excerpt_fr: blog.excerpt_fr,\n    title_es: blog.title_es,\n    content_es: blog.content_es,\n    excerpt_es: blog.excerpt_es,\n    published_at: blog.published_at,\n    parent_id: blog.parent_id,\n    // The slug will be automatically generated by the database trigger if not provided\n    slug: blog.slug\n  };\n  \n  const { data, error } = await supabase\n    .from('blogs')\n    .insert(blogToInsert)\n    .select();\n    \n  if (error) throw error;\n  return data[0];\n}\n\n// Update an existing blog post\nexport async function updateBlog(id: string, blog: Partial<Blog>) {\n  const { data, error } = await supabase\n    .from('blogs')\n    .update(blog)\n    .eq('id', id)\n    .select();\n    \n  if (error) throw error;\n  return data[0];\n}\n\n// Delete a blog post\nexport async function deleteBlog(id: string) {\n  const { error } = await supabase\n    .from('blogs')\n    .delete()\n    .eq('id', id);\n    \n  if (error) throw error;\n  return true;\n}\n"],"names":["useBlogs","page","limit","language","toast","useToast","useQuery","queryKey","queryFn","async","result","getOrSetCache","blogCache","data","start","end","error","count","supabase","from","select","eq","order","ascending","range","code","message","includes","fallbackResult","blogs","length","totalPages","details","supabaseError","localStorage","setItem","JSON","stringify","Math","ceil","timestamp","Date","now","cacheError","cachedBlogs","getItem","parsed","parse","getBlogs","ttl","STALE_TIME","title","description","variant","staleTime","gcTime","CACHE_TIME","refetchOnWindowFocus","retry","createNotFoundBlog","toISOString","id","title_en","title_fr","title_es","content_en","content_fr","content_es","excerpt_en","excerpt_fr","excerpt_es","image_url","author_id","category","created_at","updated_at","published_at","parent_id","notFound","useBlogById","blogSlug","slug","normalizedSlug","trim","toLowerCase","allBlogs","allBlogsError","blogById","find","blog","blogBySlug","createSlug","cacheKey","blogByPartialTitle","replace","cachedBlog","getBlogBySlug","enabled","retryDelay","attemptIndex","min","useBlogsByCategory","options","otherOptions","isEnabled","Boolean","normalizedCategory","ilike","getBlogsByCategory"],"mappings":"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"}