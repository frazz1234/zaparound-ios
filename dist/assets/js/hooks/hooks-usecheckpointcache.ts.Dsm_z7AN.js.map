{"version":3,"file":"hooks-usecheckpointcache.ts.Dsm_z7AN.js","sources":["../../../../src/hooks/useCheckpointCache.ts"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { tripCache, getOrSetCache, cacheEventManager, CACHE_EVENTS } from '@/utils/cache';\nimport mapboxgl from 'mapbox-gl';\n\nexport interface CheckpointData {\n  coordinates: [number, number];\n  name: string;\n  address: string;\n}\n\n// Utility function to parse coordinates\nconst parseCoordinates = (coordsData: any): [number, number] | null => {\n  if (!coordsData) return null;\n  \n  try {\n    // Case 1: Already an array\n    if (Array.isArray(coordsData) && coordsData.length === 2) {\n      const [lng, lat] = coordsData;\n      if (typeof lng === 'number' && typeof lat === 'number') {\n        return [lng, lat];\n      }\n    }\n    \n    // Case 2: JSON string of an array\n    if (typeof coordsData === 'string') {\n      try {\n        const parsed = JSON.parse(coordsData);\n        if (Array.isArray(parsed) && parsed.length === 2) {\n          const [lng, lat] = parsed;\n          if (typeof lng === 'number' && typeof lat === 'number') {\n            return [lng, lat];\n          }\n        }\n      } catch {\n        // Not a valid JSON, try other formats\n      }\n      \n      // Case 3: String format \"lat, lng\" (e.g., \"46.8144, -71.2082\")\n      if (coordsData.includes(',')) {\n        const parts = coordsData.split(',').map(part => parseFloat(part.trim()));\n        if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {\n          // Convert from lat,lng to lng,lat for Mapbox\n          return [parts[1], parts[0]];\n        }\n      }\n    }\n    \n    return null;\n  } catch (e) {\n    console.error('Error parsing coordinates:', e, coordsData);\n    return null;\n  }\n};\n\nexport function useCheckpointCache() {\n  const [loading, setLoading] = useState(false);\n\n  // Fetch ZapOut checkpoints with caching\n  const fetchZapoutCheckpoints = useCallback(async (zapoutId: string, travelMode: 'driving' | 'walking' | 'cycling' = 'driving') => {\n    const cacheKey = `zapout-checkpoints-${zapoutId}`;\n    \n    return await getOrSetCache(\n      tripCache,\n      cacheKey,\n      async () => {\n        console.log(`Fetching fresh ZapOut checkpoints for ID: ${zapoutId}`);\n        \n        const { data, error } = await supabase\n          .from('zapout_data')\n          .select('*')\n          .eq('id', zapoutId)\n          .single();\n        \n        if (error) throw error;\n        if (!data) throw new Error('No data returned for zapout ID: ' + zapoutId);\n\n        // Parse main coordinates\n        const mainCoords = parseCoordinates(data.coordinates);\n        \n        // Parse checkpoint coordinates\n        let checkpoints: CheckpointData[] = [];\n        let locationData: Array<{\n          coordinates: [number, number];\n          name: string;\n          Adresse: string;\n        }> = [];\n\n        // Add main point first\n        if (mainCoords) {\n          checkpoints.push({\n            coordinates: mainCoords,\n            name: data.title || 'Starting Point',\n            address: data.location || 'No address available'\n          });\n        }\n\n        // Parse checkpoints from various possible fields\n        if (data.checkpoints) {\n          try {\n            const parsedCheckpoints = typeof data.checkpoints === 'string'\n              ? JSON.parse(data.checkpoints)\n              : data.checkpoints;\n              \n            if (Array.isArray(parsedCheckpoints)) {\n              parsedCheckpoints.forEach((checkpoint: any) => {\n                if (checkpoint.coordinates) {\n                  const coords = parseCoordinates(checkpoint.coordinates);\n                  if (coords) {\n                    checkpoints.push({\n                      coordinates: coords,\n                      name: checkpoint.name || checkpoint.place_name || 'Unknown Location',\n                      address: checkpoint.Adresse || checkpoint.address || 'No address available'\n                    });\n                  }\n                }\n              });\n            }\n          } catch (e) {\n            console.error('Error parsing checkpoints:', e);\n          }\n        }\n\n        // Also check for geoposition field\n        if (data.geoposition) {\n          try {\n            const geopositions = typeof data.geoposition === 'string'\n              ? JSON.parse(data.geoposition)\n              : data.geoposition;\n              \n            if (Array.isArray(geopositions)) {\n              const startIndex = mainCoords ? 1 : 0;\n              geopositions.slice(startIndex).forEach((pos: any) => {\n                if (pos.coordinates) {\n                  let coords;\n                  if (Array.isArray(pos.coordinates) && pos.coordinates.length === 2) {\n                    coords = pos.coordinates as [number, number];\n                  } else {\n                    coords = parseCoordinates(pos.coordinates);\n                  }\n                  \n                  if (coords) {\n                    checkpoints.push({\n                      coordinates: coords,\n                      name: pos.place_name || pos.name || pos.location || pos.city || 'Unknown Location',\n                      address: pos.Adresse || pos.place || pos.formatted_address || pos.full_address || 'No address available'\n                    });\n                  }\n                }\n              });\n            }\n          } catch (e) {\n            console.error('Error parsing geoposition data:', e);\n          }\n        }\n\n        return {\n          checkpoints,\n          lastUpdated: Date.now()\n        };\n      },\n      { ttl: 1000 * 60 * 10 } // 10 minutes TTL for checkpoints\n    );\n  }, []);\n\n  // Fetch ZapRoad checkpoints with caching\n  const fetchZaproadCheckpoints = useCallback(async (zaproadId: string, travelMode: 'driving' | 'walking' | 'cycling' = 'driving') => {\n    const cacheKey = `zaproad-checkpoints-${zaproadId}-${travelMode}`;\n    \n    return await getOrSetCache(\n      tripCache,\n      cacheKey,\n      async () => {\n        console.log(`Fetching fresh ZapRoad checkpoints for ID: ${zaproadId} with mode: ${travelMode}`);\n        \n        const { data, error } = await supabase\n          .from('zaproad_data')\n          .select('*')\n          .eq('id', zaproadId)\n          .single();\n        \n        if (error) throw error;\n        if (!data) throw new Error('No data returned for zaproad ID: ' + zaproadId);\n\n        // Parse main coordinates\n        const mainCoords = parseCoordinates(data.starting_city_coordinates);\n        const endCoords = data.end_city_coordinates \n          ? parseCoordinates(data.end_city_coordinates)\n          : null;\n        \n        let checkpoints: CheckpointData[] = [];\n        let routePoints: [number, number][] = [];\n\n        // Add starting point first\n        if (mainCoords) {\n          checkpoints.push({\n            coordinates: mainCoords,\n            name: data.starting_city || 'Starting Point',\n            address: data.starting_city || 'No address available'\n          });\n          routePoints.push(mainCoords);\n        }\n\n        // Add end point if available\n        if (endCoords) {\n          checkpoints.push({\n            coordinates: endCoords,\n            name: data.end_city || 'End Point',\n            address: data.end_city || 'No address available'\n          });\n          routePoints.push(endCoords);\n        }\n\n        // Parse stopover cities\n        if (data.stopover_cities) {\n          try {\n            const stopoverCities = typeof data.stopover_cities === 'string'\n              ? JSON.parse(data.stopover_cities)\n              : data.stopover_cities;\n              \n            if (Array.isArray(stopoverCities)) {\n              stopoverCities.forEach((city: any) => {\n                if (city.coordinates) {\n                  const coords = parseCoordinates(city.coordinates);\n                  if (coords) {\n                    checkpoints.push({\n                      coordinates: coords,\n                      name: city.name || 'Stopover',\n                      address: city.name || 'No address available'\n                    });\n                    routePoints.push(coords);\n                  }\n                }\n              });\n            }\n          } catch (e) {\n            console.error('Error parsing stopover cities:', e);\n          }\n        }\n\n        // Get route between points if we have multiple points\n        let routeGeometry = null;\n        if (routePoints.length >= 2) {\n          try {\n            const coordinates = routePoints.map(p => p.join(',')).join(';');\n            const response = await fetch(\n              `https://api.mapbox.com/directions/v5/mapbox/${travelMode}/${coordinates}?` +\n              `geometries=geojson&overview=full&radiuses=${routePoints.map(() => '50').join(';')}&` +\n              `approaches=${routePoints.map(() => 'curb').join(';')}&` +\n              `waypoints=${routePoints.map((_, i) => i).join(';')}&` +\n              `access_token=${mapboxgl.accessToken}`\n            );\n            \n            const data = await response.json();\n            if (data.routes && data.routes.length > 0) {\n              routeGeometry = data.routes[0].geometry.coordinates;\n            }\n          } catch (error) {\n            console.error('Error fetching route:', error);\n          }\n        }\n\n        return {\n          checkpoints,\n          routeGeometry,\n          lastUpdated: Date.now()\n        };\n      },\n      { ttl: 1000 * 60 * 10 } // 10 minutes TTL for checkpoints\n    );\n  }, []);\n\n  // Fetch ZapTrip checkpoints with caching\n  const fetchZaptripCheckpoints = useCallback(async (zaptripId: string) => {\n    const cacheKey = `zaptrip-checkpoints-${zaptripId}`;\n    \n    return await getOrSetCache(\n      tripCache,\n      cacheKey,\n      async () => {\n        console.log(`Fetching fresh ZapTrip checkpoints for ID: ${zaptripId}`);\n        \n        const { data, error } = await supabase\n          .from('trips')\n          .select('*')\n          .eq('id', zaptripId)\n          .single();\n        \n        if (error) throw error;\n        if (!data) throw new Error('No data returned for zaptrip ID: ' + zaptripId);\n\n        // Parse main coordinates\n        const mainCoords = parseCoordinates(data.coordinates);\n        \n        let checkpoints: CheckpointData[] = [];\n\n        // Add main point first\n        if (mainCoords) {\n          checkpoints.push({\n            coordinates: mainCoords,\n            name: data.title || 'Starting Point',\n            address: data.location || 'No address available'\n          });\n        }\n\n        // Parse checkpoints from various possible fields\n        if (data.checkpoints) {\n          try {\n            const parsedCheckpoints = typeof data.checkpoints === 'string'\n              ? JSON.parse(data.checkpoints)\n              : data.checkpoints;\n              \n            if (Array.isArray(parsedCheckpoints)) {\n              parsedCheckpoints.forEach((checkpoint: any) => {\n                if (checkpoint.coordinates) {\n                  const coords = parseCoordinates(checkpoint.coordinates);\n                  if (coords) {\n                    checkpoints.push({\n                      coordinates: coords,\n                      name: checkpoint.name || checkpoint.place_name || 'Unknown Location',\n                      address: checkpoint.Adresse || checkpoint.address || 'No address available'\n                    });\n                  }\n                }\n              });\n            }\n          } catch (e) {\n            console.error('Error parsing checkpoints:', e);\n          }\n        }\n\n        // Also check for geoposition field\n        if (data.geoposition) {\n          try {\n            const geopositions = typeof data.geoposition === 'string'\n              ? JSON.parse(data.geoposition)\n              : data.geoposition;\n              \n            if (Array.isArray(geopositions)) {\n              const startIndex = mainCoords ? 1 : 0;\n              geopositions.slice(startIndex).forEach((pos: any) => {\n                if (pos.coordinates) {\n                  let coords;\n                  if (Array.isArray(pos.coordinates) && pos.coordinates.length === 2) {\n                    coords = pos.coordinates as [number, number];\n                  } else {\n                    coords = parseCoordinates(pos.coordinates);\n                  }\n                  \n                  if (coords) {\n                    checkpoints.push({\n                      coordinates: coords,\n                      name: pos.place_name || pos.name || pos.location || pos.city || 'Unknown Location',\n                      address: pos.Adresse || pos.place || pos.formatted_address || pos.full_address || 'No address available'\n                    });\n                  }\n                }\n              });\n            }\n          } catch (e) {\n            console.error('Error parsing geoposition data:', e);\n          }\n        }\n\n        return {\n          checkpoints,\n          lastUpdated: Date.now()\n        };\n      },\n      { ttl: 1000 * 60 * 10 } // 10 minutes TTL for checkpoints\n    );\n  }, []);\n\n  // Invalidate checkpoint cache for a specific trip\n  const invalidateCheckpointCache = useCallback((tripId: string, tripType: 'zapout' | 'zaproad' | 'zaptrip') => {\n    const cacheKey = `${tripType}-checkpoints-${tripId}`;\n    tripCache.delete(cacheKey);\n    console.log(`Checkpoint cache invalidated for ${tripType} trip: ${tripId}`);\n  }, []);\n\n  // Clear all checkpoint caches\n  const clearAllCheckpointCaches = useCallback(() => {\n    const keys = Array.from(tripCache.keys());\n    keys.forEach(key => {\n      if (key.includes('-checkpoints-')) {\n        tripCache.delete(key);\n      }\n    });\n    console.log('All checkpoint caches cleared');\n  }, []);\n\n  // Listen for cache invalidation events\n  useEffect(() => {\n    const unsubscribeCheckpointsInvalidated = cacheEventManager.subscribe(CACHE_EVENTS.CHECKPOINTS_INVALIDATED, () => {\n      console.log('Checkpoints invalidated event received, clearing checkpoint caches...');\n      clearAllCheckpointCaches();\n    });\n\n    const unsubscribeTripCreated = cacheEventManager.subscribe(CACHE_EVENTS.TRIP_CREATED, () => {\n      console.log('Trip created event received, clearing checkpoint caches...');\n      clearAllCheckpointCaches();\n    });\n\n    // Cleanup subscriptions\n    return () => {\n      unsubscribeCheckpointsInvalidated();\n      unsubscribeTripCreated();\n    };\n  }, [clearAllCheckpointCaches]);\n\n  return {\n    loading,\n    fetchZapoutCheckpoints,\n    fetchZaproadCheckpoints,\n    fetchZaptripCheckpoints,\n    invalidateCheckpointCache,\n    clearAllCheckpointCaches\n  };\n} "],"names":["parseCoordinates","coordsData","Array","isArray","length","lng","lat","parsed","JSON","parse","includes","parts","split","map","part","parseFloat","trim","isNaN","e","useCheckpointCache","loading","setLoading","useState","fetchZapoutCheckpoints","useCallback","async","zapoutId","travelMode","cacheKey","getOrSetCache","tripCache","data","error","supabase","from","select","eq","single","Error","mainCoords","coordinates","checkpoints","push","name","title","address","location","parsedCheckpoints","forEach","checkpoint","coords","place_name","Adresse","geoposition","geopositions","startIndex","slice","pos","city","place","formatted_address","full_address","lastUpdated","Date","now","ttl","fetchZaproadCheckpoints","zaproadId","starting_city_coordinates","endCoords","end_city_coordinates","routePoints","starting_city","end_city","stopover_cities","stopoverCities","routeGeometry","p","join","response","fetch","_","i","mapboxgl","accessToken","json","routes","geometry","fetchZaptripCheckpoints","zaptripId","invalidateCheckpointCache","tripId","tripType","delete","clearAllCheckpointCaches","keys","key","useEffect","unsubscribeCheckpointsInvalidated","cacheEventManager","subscribe","CACHE_EVENTS","CHECKPOINTS_INVALIDATED","unsubscribeTripCreated","TRIP_CREATED"],"mappings":"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"}