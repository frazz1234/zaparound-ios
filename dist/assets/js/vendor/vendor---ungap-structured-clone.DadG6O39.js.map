{"version":3,"file":"vendor---ungap-structured-clone.DadG6O39.js","sources":["../../../../node_modules/@ungap/structured-clone/esm/types.js","../../../../node_modules/@ungap/structured-clone/esm/deserialize.js","../../../../node_modules/@ungap/structured-clone/esm/serialize.js","../../../../node_modules/@ungap/structured-clone/esm/index.js"],"sourcesContent":["export const VOID       = -1;\nexport const PRIMITIVE  = 0;\nexport const ARRAY      = 1;\nexport const OBJECT     = 2;\nexport const DATE       = 3;\nexport const REGEXP     = 4;\nexport const MAP        = 5;\nexport const SET        = 6;\nexport const ERROR      = 7;\nexport const BIGINT     = 8;\n// export const SYMBOL = 9;\n","import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst env = typeof self === 'object' ? self : globalThis;\n\nconst deserializer = ($, _) => {\n  const as = (out, index) => {\n    $.set(index, out);\n    return out;\n  };\n\n  const unpair = index => {\n    if ($.has(index))\n      return $.get(index);\n\n    const [type, value] = _[index];\n    switch (type) {\n      case PRIMITIVE:\n      case VOID:\n        return as(value, index);\n      case ARRAY: {\n        const arr = as([], index);\n        for (const index of value)\n          arr.push(unpair(index));\n        return arr;\n      }\n      case OBJECT: {\n        const object = as({}, index);\n        for (const [key, index] of value)\n          object[unpair(key)] = unpair(index);\n        return object;\n      }\n      case DATE:\n        return as(new Date(value), index);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as(new RegExp(source, flags), index);\n      }\n      case MAP: {\n        const map = as(new Map, index);\n        for (const [key, index] of value)\n          map.set(unpair(key), unpair(index));\n        return map;\n      }\n      case SET: {\n        const set = as(new Set, index);\n        for (const index of value)\n          set.add(unpair(index));\n        return set;\n      }\n      case ERROR: {\n        const {name, message} = value;\n        return as(new env[name](message), index);\n      }\n      case BIGINT:\n        return as(BigInt(value), index);\n      case 'BigInt':\n        return as(Object(BigInt(value)), index);\n      case 'ArrayBuffer':\n        return as(new Uint8Array(value).buffer, value);\n      case 'DataView': {\n        const { buffer } = new Uint8Array(value);\n        return as(new DataView(buffer), value);\n      }\n    }\n    return as(new env[type](value), index);\n  };\n\n  return unpair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns a deserialized value from a serialized array of Records.\n * @param {Record[]} serialized a previously serialized value.\n * @returns {any}\n */\nexport const deserialize = serialized => deserializer(new Map, serialized)(0);\n","import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst EMPTY = '';\n\nconst {toString} = {};\nconst {keys} = Object;\n\nconst typeOf = value => {\n  const type = typeof value;\n  if (type !== 'object' || !value)\n    return [PRIMITIVE, type];\n\n  const asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n    case 'Object':\n      return [OBJECT, EMPTY];\n    case 'Date':\n      return [DATE, EMPTY];\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n    case 'Map':\n      return [MAP, EMPTY];\n    case 'Set':\n      return [SET, EMPTY];\n    case 'DataView':\n      return [ARRAY, asString];\n  }\n\n  if (asString.includes('Array'))\n    return [ARRAY, asString];\n\n  if (asString.includes('Error'))\n    return [ERROR, asString];\n\n  return [OBJECT, asString];\n};\n\nconst shouldSkip = ([TYPE, type]) => (\n  TYPE === PRIMITIVE &&\n  (type === 'function' || type === 'symbol')\n);\n\nconst serializer = (strict, json, $, _) => {\n\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n\n  const pair = value => {\n    if ($.has(value))\n      return $.get(value);\n\n    let [TYPE, type] = typeOf(value);\n    switch (TYPE) {\n      case PRIMITIVE: {\n        let entry = value;\n        switch (type) {\n          case 'bigint':\n            TYPE = BIGINT;\n            entry = value.toString();\n            break;\n          case 'function':\n          case 'symbol':\n            if (strict)\n              throw new TypeError('unable to serialize ' + type);\n            entry = null;\n            break;\n          case 'undefined':\n            return as([VOID], value);\n        }\n        return as([TYPE, entry], value);\n      }\n      case ARRAY: {\n        if (type) {\n          let spread = value;\n          if (type === 'DataView') {\n            spread = new Uint8Array(value.buffer);\n          }\n          else if (type === 'ArrayBuffer') {\n            spread = new Uint8Array(value);\n          }\n          return as([type, [...spread]], value);\n        }\n\n        const arr = [];\n        const index = as([TYPE, arr], value);\n        for (const entry of value)\n          arr.push(pair(entry));\n        return index;\n      }\n      case OBJECT: {\n        if (type) {\n          switch (type) {\n            case 'BigInt':\n              return as([type, value.toString()], value);\n            case 'Boolean':\n            case 'Number':\n            case 'String':\n              return as([type, value.valueOf()], value);\n          }\n        }\n\n        if (json && ('toJSON' in value))\n          return pair(value.toJSON());\n\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const key of keys(value)) {\n          if (strict || !shouldSkip(typeOf(value[key])))\n            entries.push([pair(key), pair(value[key])]);\n        }\n        return index;\n      }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as([TYPE, {source, flags}], value);\n      }\n      case MAP: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const [key, entry] of value) {\n          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))\n            entries.push([pair(key), pair(entry)]);\n        }\n        return index;\n      }\n      case SET: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const entry of value) {\n          if (strict || !shouldSkip(typeOf(entry)))\n            entries.push(pair(entry));\n        }\n        return index;\n      }\n    }\n\n    const {message} = value;\n    return as([TYPE, {name: type, message}], value);\n  };\n\n  return pair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\n export const serialize = (value, {json, lossy} = {}) => {\n  const _ = [];\n  return serializer(!(json || lossy), !!json, new Map, _)(value), _;\n};\n","import {deserialize} from './deserialize.js';\nimport {serialize} from './serialize.js';\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} any a serializable value.\n * @param {{transfer?: any[], json?: boolean, lossy?: boolean}?} options an object with\n * a transfer option (ignored when polyfilled) and/or non standard fields that\n * fallback to the polyfill if present.\n * @returns {Record[]}\n */\nexport default typeof structuredClone === \"function\" ?\n  /* c8 ignore start */\n  (any, options) => (\n    options && ('json' in options || 'lossy' in options) ?\n      deserialize(serialize(any, options)) : structuredClone(any)\n  ) :\n  (any, options) => deserialize(serialize(any, options));\n  /* c8 ignore stop */\n\nexport {deserialize, serialize};\n"],"names":["env","self","globalThis","deserialize","serialized","$","_","as","out","index","set","unpair","has","get","type","value","arr","push","object","key","Date","source","flags","RegExp","map","Map","Set","add","name","message","BigInt","Object","Uint8Array","buffer","DataView","deserializer","EMPTY","toString","keys","typeOf","asString","call","slice","includes","shouldSkip","TYPE","serialize","json","lossy","strict","pair","entry","TypeError","spread","valueOf","toJSON","entries","toISOString","serializer","structuredClone$1","structuredClone","any","options"],"mappings":"AAAO,MCODA,EAAsB,iBAATC,KAAoBA,KAAOC,WA6EjCC,EAAcC,GA3EN,EAACC,EAAGC,KACvB,MAAMC,EAAK,CAACC,EAAKC,KACfJ,EAAEK,IAAID,EAAOD,GACNA,GAGHG,EAASF,IACb,GAAIJ,EAAEO,IAAIH,GACR,OAAOJ,EAAEQ,IAAIJ,GAEf,MAAOK,EAAMC,GAAST,EAAEG,GACxB,OAAQK,GACN,KDpBoB,ECqBpB,KDtBoB,ECuBlB,OAAOP,EAAGQ,EAAON,GACnB,KDtBoB,ECsBR,CACV,MAAMO,EAAMT,EAAG,GAAIE,GACnB,IAAK,MAAMA,KAASM,EAClBC,EAAIC,KAAKN,EAAOF,IAClB,OAAOO,CACf,CACM,KD3BoB,EC2BP,CACX,MAAME,EAASX,EAAG,CAAE,EAAEE,GACtB,IAAK,MAAOU,EAAKV,KAAUM,EACzBG,EAAOP,EAAOQ,IAAQR,EAAOF,GAC/B,OAAOS,CACf,CACM,KDhCoB,ECiClB,OAAOX,EAAG,IAAIa,KAAKL,GAAQN,GAC7B,KDjCoB,ECiCP,CACX,MAAMY,OAACA,EAAMC,MAAEA,GAASP,EACxB,OAAOR,EAAG,IAAIgB,OAAOF,EAAQC,GAAQb,EAC7C,CACM,KDpCoB,ECoCV,CACR,MAAMe,EAAMjB,EAAG,IAAIkB,IAAKhB,GACxB,IAAK,MAAOU,EAAKV,KAAUM,EACzBS,EAAId,IAAIC,EAAOQ,GAAMR,EAAOF,IAC9B,OAAOe,CACf,CACM,KDzCoB,ECyCV,CACR,MAAMd,EAAMH,EAAG,IAAImB,IAAKjB,GACxB,IAAK,MAAMA,KAASM,EAClBL,EAAIiB,IAAIhB,EAAOF,IACjB,OAAOC,CACf,CACM,KD9CoB,EC8CR,CACV,MAAMkB,KAACA,EAAIC,QAAEA,GAAWd,EACxB,OAAOR,EAAG,IAAIP,EAAI4B,GAAMC,GAAUpB,EAC1C,CACM,KDjDoB,ECkDlB,OAAOF,EAAGuB,OAAOf,GAAQN,GAC3B,IAAK,SACH,OAAOF,EAAGwB,OAAOD,OAAOf,IAASN,GACnC,IAAK,cACH,OAAOF,EAAG,IAAIyB,WAAWjB,GAAOkB,OAAQlB,GAC1C,IAAK,WAAY,CACf,MAAMkB,OAAEA,GAAW,IAAID,WAAWjB,GAClC,OAAOR,EAAG,IAAI2B,SAASD,GAASlB,EACxC,EAEI,OAAOR,EAAG,IAAIP,EAAIc,GAAMC,GAAQN,EAAM,EAGxC,OAAOE,CAAM,EAY0BwB,CAAa,IAAIV,IAAKrB,EAAtB+B,CAAkC,GC7ErEC,EAAQ,IAERC,SAACA,GAAY,CAAE,GACfC,KAACA,GAAQP,OAETQ,EAASxB,IACb,MAAMD,SAAcC,EACpB,GAAa,WAATD,IAAsBC,EACxB,MAAO,CFde,EEcHD,GAErB,MAAM0B,EAAWH,EAASI,KAAK1B,GAAO2B,MAAM,MAC5C,OAAQF,GACN,IAAK,QACH,MAAO,CFlBa,EEkBLJ,GACjB,IAAK,SACH,MAAO,CFnBa,EEmBJA,GAClB,IAAK,OACH,MAAO,CFpBa,EEoBNA,GAChB,IAAK,SACH,MAAO,CFrBa,EEqBJA,GAClB,IAAK,MACH,MAAO,CFtBa,EEsBPA,GACf,IAAK,MACH,MAAO,CFvBa,EEuBPA,GACf,IAAK,WACH,MAAO,CF9Ba,EE8BLI,GAGnB,OAAIA,EAASG,SAAS,SACb,CFlCe,EEkCPH,GAEbA,EAASG,SAAS,SACb,CF/Be,EE+BPH,GAEV,CFtCiB,EEsCRA,EAAS,EAGrBI,EAAa,EAAEC,EAAM/B,KF3CD,IE4CxB+B,IACU,aAAT/B,GAAgC,WAATA,GAyHZgC,EAAY,CAAC/B,GAAQgC,OAAMC,SAAS,MAChD,MAAM1C,EAAI,GACV,MAxHiB,EAAC2C,EAAQF,EAAM1C,EAAGC,KAEnC,MAAMC,EAAK,CAACC,EAAKO,KACf,MAAMN,EAAQH,EAAEW,KAAKT,GAAO,EAE5B,OADAH,EAAEK,IAAIK,EAAON,GACNA,CAAK,EAGRyC,EAAOnC,IACX,GAAIV,EAAEO,IAAIG,GACR,OAAOV,EAAEQ,IAAIE,GAEf,IAAK8B,EAAM/B,GAAQyB,EAAOxB,GAC1B,OAAQ8B,GACN,KF9DoB,EE8DJ,CACd,IAAIM,EAAQpC,EACZ,OAAQD,GACN,IAAK,SACH+B,EF1Dc,EE2DdM,EAAQpC,EAAMsB,WACd,MACF,IAAK,WACL,IAAK,SACH,GAAIY,EACF,MAAM,IAAIG,UAAU,uBAAyBtC,GAC/CqC,EAAQ,KACR,MACF,IAAK,YACH,OAAO5C,EAAG,EF7EI,GE6EIQ,GAEtB,OAAOR,EAAG,CAACsC,EAAMM,GAAQpC,EACjC,CACM,KF/EoB,EE+ER,CACV,GAAID,EAAM,CACR,IAAIuC,EAAStC,EAOb,MANa,aAATD,EACFuC,EAAS,IAAIrB,WAAWjB,EAAMkB,QAEd,gBAATnB,IACPuC,EAAS,IAAIrB,WAAWjB,IAEnBR,EAAG,CAACO,EAAM,IAAIuC,IAAUtC,EACzC,CAEQ,MAAMC,EAAM,GACNP,EAAQF,EAAG,CAACsC,EAAM7B,GAAMD,GAC9B,IAAK,MAAMoC,KAASpC,EAClBC,EAAIC,KAAKiC,EAAKC,IAChB,OAAO1C,CACf,CACM,KFhGoB,EEgGP,CACX,GAAIK,EACF,OAAQA,GACN,IAAK,SACH,OAAOP,EAAG,CAACO,EAAMC,EAAMsB,YAAatB,GACtC,IAAK,UACL,IAAK,SACL,IAAK,SACH,OAAOR,EAAG,CAACO,EAAMC,EAAMuC,WAAYvC,GAIzC,GAAIgC,GAAS,WAAYhC,EACvB,OAAOmC,EAAKnC,EAAMwC,UAEpB,MAAMC,EAAU,GACV/C,EAAQF,EAAG,CAACsC,EAAMW,GAAUzC,GAClC,IAAK,MAAMI,KAAOmB,EAAKvB,IACjBkC,GAAWL,EAAWL,EAAOxB,EAAMI,MACrCqC,EAAQvC,KAAK,CAACiC,EAAK/B,GAAM+B,EAAKnC,EAAMI,MAExC,OAAOV,CACf,CACM,KFtHoB,EEuHlB,OAAOF,EAAG,CAACsC,EAAM9B,EAAM0C,eAAgB1C,GACzC,KFvHoB,EEuHP,CACX,MAAMM,OAACA,EAAMC,MAAEA,GAASP,EACxB,OAAOR,EAAG,CAACsC,EAAM,CAACxB,SAAQC,UAASP,EAC3C,CACM,KF1HoB,EE0HV,CACR,MAAMyC,EAAU,GACV/C,EAAQF,EAAG,CAACsC,EAAMW,GAAUzC,GAClC,IAAK,MAAOI,EAAKgC,KAAUpC,GACrBkC,IAAYL,EAAWL,EAAOpB,MAASyB,EAAWL,EAAOY,MAC3DK,EAAQvC,KAAK,CAACiC,EAAK/B,GAAM+B,EAAKC,KAElC,OAAO1C,CACf,CACM,KFlIoB,EEkIV,CACR,MAAM+C,EAAU,GACV/C,EAAQF,EAAG,CAACsC,EAAMW,GAAUzC,GAClC,IAAK,MAAMoC,KAASpC,GACdkC,GAAWL,EAAWL,EAAOY,KAC/BK,EAAQvC,KAAKiC,EAAKC,IAEtB,OAAO1C,CACf,EAGI,MAAMoB,QAACA,GAAWd,EAClB,OAAOR,EAAG,CAACsC,EAAM,CAACjB,KAAMd,EAAMe,YAAWd,EAAM,EAGjD,OAAOmC,CAAI,EAiBJQ,GAAaX,GAAQC,KAAUD,EAAM,IAAItB,IAAKnB,EAA9CoD,CAAiD3C,GAAQT,CAAC,EC1JpDqD,EAA2B,mBAApBC,gBAEpB,CAACC,EAAKC,IACJA,IAAY,SAAUA,GAAW,UAAWA,GAC1C3D,EAAY2C,EAAUe,EAAKC,IAAYF,gBAAgBC,GAE3D,CAACA,EAAKC,IAAY3D,EAAY2C,EAAUe,EAAKC","x_google_ignoreList":[0,1,2,3]}