{"version":3,"file":"vendor--lru-cache.CYB7PIxo.js","sources":["../../../../node_modules/lru-cache/dist/esm/index.js"],"sourcesContent":["/**\n * @module LRUCache\n */\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache {\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #onInsert;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    #hasOnInsert;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.onInsert} (read-only)\n     */\n    get onInsert() {\n        return this.#onInsert;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (memoMethod !== undefined &&\n            typeof memoMethod !== 'function') {\n            throw new TypeError('memoMethod must be a function if defined');\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof onInsert === 'function') {\n            this.#onInsert = onInsert;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasOnInsert = !!this.#onInsert;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], 'expire');\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    [Symbol.toStringTag] = 'LRUCache';\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], 'expire');\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, 'set');\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n            if (this.#hasOnInsert) {\n                this.#onInsert?.(v, k, 'add');\n            }\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n            if (this.#hasOnInsert) {\n                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.#delete(k, 'fetch');\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, 'fetch');\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined)\n            throw new Error('fetch() returned undefined');\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error('no memoMethod provided to constructor');\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined)\n            return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context,\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, 'expire');\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        return this.#delete(k, 'delete');\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, reason]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        return this.#clear('delete');\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, reason]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map"],"names":["perf","performance","now","Date","warned","Set","PROCESS","process","emitWarning","msg","type","code","fn","AC","globalThis","AbortController","AS","AbortSignal","onabort","_onabort","reason","aborted","addEventListener","_","this","push","constructor","warnACPolyfill","signal","abort","printACPolyfillWarning","env","LRU_CACHE_IGNORE_AC_WARNING","isPosInt","n","Math","floor","isFinite","getUintArray","max","pow","Uint8Array","Uint16Array","Uint32Array","Number","MAX_SAFE_INTEGER","ZeroArray","Array","size","super","fill","Stack","heap","length","static","create","HeapCls","constructing","s","TypeError","pop","LRUCache","maxSize","dispose","onInsert","disposeAfter","fetchMethod","memoMethod","ttl","ttlResolution","ttlAutopurge","updateAgeOnGet","updateAgeOnHas","allowStale","noDisposeOnSet","noUpdateTTL","maxEntrySize","sizeCalculation","noDeleteOnFetchRejection","noDeleteOnStaleGet","allowStaleOnFetchAbort","allowStaleOnFetchRejection","ignoreFetchAbort","calculatedSize","keyMap","keyList","valList","next","prev","head","tail","free","disposed","sizes","starts","ttls","hasDispose","hasFetchMethod","hasDisposeAfter","hasOnInsert","unsafeExposeInternals","c","isBackgroundFetch","p","backgroundFetch","k","index","options","context","moveToTail","indexes","rindexes","isStale","UintArray","Error","undefined","Map","initializeSizeTracking","initializeTTLTracking","has","shouldWarn","add","getRemainingTTL","key","Infinity","setItemTTL","start","t","setTimeout","delete","unref","updateItemAge","statusTTL","status","cachedNow","getNow","age","remainingTTL","get","removeItemSize","requireSize","v","addItemSize","evict","entrySize","totalCalculatedSize","_i","_s","_st","_k","_v","i","isValidIndex","entries","rentries","keys","rkeys","values","rvalues","Symbol","iterator","toStringTag","find","getOptions","value","__staleWhileFetching","forEach","thisp","call","rforEach","purgeStale","deleted","info","entry","remain","dump","arr","unshift","load","clear","set","setOptions","maxEntrySizeExceeded","oldVal","__abortController","oldValue","dt","task","shift","val","hasOptions","peek","peekOptions","ac","fetchOpts","cb","updateCache","ignoreAbort","fetchAborted","fetchError","fetchAbortIgnored","fetchResolved","fetchFail","bf","fetchUpdated","er","allowStaleAborted","noDelete","returnedStale","__returned","fetchDispatched","Promise","res","rej","fmp","then","fetchRejected","Object","assign","b","hasOwnProperty","fetch","fetchOptions","forceRefresh","stale","staleVal","forceFetch","memo","memoOptions","vv","fetching","connect","pi","ni"],"mappings":"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","x_google_ignoreList":[0]}