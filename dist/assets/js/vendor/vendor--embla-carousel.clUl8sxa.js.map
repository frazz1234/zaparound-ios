{"version":3,"file":"vendor--embla-carousel.clUl8sxa.js","sources":["../../../../node_modules/embla-carousel/esm/embla-carousel.esm.js"],"sourcesContent":["function isNumber(subject) {\n  return typeof subject === 'number';\n}\nfunction isString(subject) {\n  return typeof subject === 'string';\n}\nfunction isBoolean(subject) {\n  return typeof subject === 'boolean';\n}\nfunction isObject(subject) {\n  return Object.prototype.toString.call(subject) === '[object Object]';\n}\nfunction mathAbs(n) {\n  return Math.abs(n);\n}\nfunction mathSign(n) {\n  return Math.sign(n);\n}\nfunction deltaAbs(valueB, valueA) {\n  return mathAbs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n  if (valueB === 0 || valueA === 0) return 0;\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0;\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n  return mathAbs(diff / valueB);\n}\nfunction roundToTwoDecimals(num) {\n  return Math.round(num * 100) / 100;\n}\nfunction arrayKeys(array) {\n  return objectKeys(array).map(Number);\n}\nfunction arrayLast(array) {\n  return array[arrayLastIndex(array)];\n}\nfunction arrayLastIndex(array) {\n  return Math.max(0, array.length - 1);\n}\nfunction arrayIsLastIndex(array, index) {\n  return index === arrayLastIndex(array);\n}\nfunction arrayFromNumber(n, startAt = 0) {\n  return Array.from(Array(n), (_, i) => startAt + i);\n}\nfunction objectKeys(object) {\n  return Object.keys(object);\n}\nfunction objectsMergeDeep(objectA, objectB) {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach(key => {\n      const valueA = mergedObjects[key];\n      const valueB = currentObject[key];\n      const areObjects = isObject(valueA) && isObject(valueB);\n      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n    });\n    return mergedObjects;\n  }, {});\n}\nfunction isMouseEvent(evt, ownerWindow) {\n  return typeof ownerWindow.MouseEvent !== 'undefined' && evt instanceof ownerWindow.MouseEvent;\n}\n\nfunction Alignment(align, viewSize) {\n  const predefined = {\n    start,\n    center,\n    end\n  };\n  function start() {\n    return 0;\n  }\n  function center(n) {\n    return end(n) / 2;\n  }\n  function end(n) {\n    return viewSize - n;\n  }\n  function measure(n, index) {\n    if (isString(align)) return predefined[align](n);\n    return align(viewSize, n, index);\n  }\n  const self = {\n    measure\n  };\n  return self;\n}\n\nfunction EventStore() {\n  let listeners = [];\n  function add(node, type, handler, options = {\n    passive: true\n  }) {\n    let removeListener;\n    if ('addEventListener' in node) {\n      node.addEventListener(type, handler, options);\n      removeListener = () => node.removeEventListener(type, handler, options);\n    } else {\n      const legacyMediaQueryList = node;\n      legacyMediaQueryList.addListener(handler);\n      removeListener = () => legacyMediaQueryList.removeListener(handler);\n    }\n    listeners.push(removeListener);\n    return self;\n  }\n  function clear() {\n    listeners = listeners.filter(remove => remove());\n  }\n  const self = {\n    add,\n    clear\n  };\n  return self;\n}\n\nfunction Animations(ownerDocument, ownerWindow, update, render) {\n  const documentVisibleHandler = EventStore();\n  const fixedTimeStep = 1000 / 60;\n  let lastTimeStamp = null;\n  let accumulatedTime = 0;\n  let animationId = 0;\n  function init() {\n    documentVisibleHandler.add(ownerDocument, 'visibilitychange', () => {\n      if (ownerDocument.hidden) reset();\n    });\n  }\n  function destroy() {\n    stop();\n    documentVisibleHandler.clear();\n  }\n  function animate(timeStamp) {\n    if (!animationId) return;\n    if (!lastTimeStamp) {\n      lastTimeStamp = timeStamp;\n      update();\n      update();\n    }\n    const timeElapsed = timeStamp - lastTimeStamp;\n    lastTimeStamp = timeStamp;\n    accumulatedTime += timeElapsed;\n    while (accumulatedTime >= fixedTimeStep) {\n      update();\n      accumulatedTime -= fixedTimeStep;\n    }\n    const alpha = accumulatedTime / fixedTimeStep;\n    render(alpha);\n    if (animationId) {\n      animationId = ownerWindow.requestAnimationFrame(animate);\n    }\n  }\n  function start() {\n    if (animationId) return;\n    animationId = ownerWindow.requestAnimationFrame(animate);\n  }\n  function stop() {\n    ownerWindow.cancelAnimationFrame(animationId);\n    lastTimeStamp = null;\n    accumulatedTime = 0;\n    animationId = 0;\n  }\n  function reset() {\n    lastTimeStamp = null;\n    accumulatedTime = 0;\n  }\n  const self = {\n    init,\n    destroy,\n    start,\n    stop,\n    update,\n    render\n  };\n  return self;\n}\n\nfunction Axis(axis, contentDirection) {\n  const isRightToLeft = contentDirection === 'rtl';\n  const isVertical = axis === 'y';\n  const scroll = isVertical ? 'y' : 'x';\n  const cross = isVertical ? 'x' : 'y';\n  const sign = !isVertical && isRightToLeft ? -1 : 1;\n  const startEdge = getStartEdge();\n  const endEdge = getEndEdge();\n  function measureSize(nodeRect) {\n    const {\n      height,\n      width\n    } = nodeRect;\n    return isVertical ? height : width;\n  }\n  function getStartEdge() {\n    if (isVertical) return 'top';\n    return isRightToLeft ? 'right' : 'left';\n  }\n  function getEndEdge() {\n    if (isVertical) return 'bottom';\n    return isRightToLeft ? 'left' : 'right';\n  }\n  function direction(n) {\n    return n * sign;\n  }\n  const self = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n    direction\n  };\n  return self;\n}\n\nfunction Limit(min = 0, max = 0) {\n  const length = mathAbs(min - max);\n  function reachedMin(n) {\n    return n < min;\n  }\n  function reachedMax(n) {\n    return n > max;\n  }\n  function reachedAny(n) {\n    return reachedMin(n) || reachedMax(n);\n  }\n  function constrain(n) {\n    if (!reachedAny(n)) return n;\n    return reachedMin(n) ? min : max;\n  }\n  function removeOffset(n) {\n    if (!length) return n;\n    return n - length * Math.ceil((n - max) / length);\n  }\n  const self = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset\n  };\n  return self;\n}\n\nfunction Counter(max, start, loop) {\n  const {\n    constrain\n  } = Limit(0, max);\n  const loopEnd = max + 1;\n  let counter = withinLimit(start);\n  function withinLimit(n) {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n  }\n  function get() {\n    return counter;\n  }\n  function set(n) {\n    counter = withinLimit(n);\n    return self;\n  }\n  function add(n) {\n    return clone().set(get() + n);\n  }\n  function clone() {\n    return Counter(max, get(), loop);\n  }\n  const self = {\n    get,\n    set,\n    add,\n    clone\n  };\n  return self;\n}\n\nfunction DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {\n  const {\n    cross: crossAxis,\n    direction\n  } = axis;\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA'];\n  const nonPassiveEvent = {\n    passive: false\n  };\n  const initEvents = EventStore();\n  const dragEvents = EventStore();\n  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));\n  const snapForceBoost = {\n    mouse: 300,\n    touch: 400\n  };\n  const freeForceBoost = {\n    mouse: 500,\n    touch: 600\n  };\n  const baseSpeed = dragFree ? 43 : 25;\n  let isMoving = false;\n  let startScroll = 0;\n  let startCross = 0;\n  let pointerIsDown = false;\n  let preventScroll = false;\n  let preventClick = false;\n  let isMouse = false;\n  function init(emblaApi) {\n    if (!watchDrag) return;\n    function downIfAllowed(evt) {\n      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);\n    }\n    const node = rootNode;\n    initEvents.add(node, 'dragstart', evt => evt.preventDefault(), nonPassiveEvent).add(node, 'touchmove', () => undefined, nonPassiveEvent).add(node, 'touchend', () => undefined).add(node, 'touchstart', downIfAllowed).add(node, 'mousedown', downIfAllowed).add(node, 'touchcancel', up).add(node, 'contextmenu', up).add(node, 'click', click, true);\n  }\n  function destroy() {\n    initEvents.clear();\n    dragEvents.clear();\n  }\n  function addDragEvents() {\n    const node = isMouse ? ownerDocument : rootNode;\n    dragEvents.add(node, 'touchmove', move, nonPassiveEvent).add(node, 'touchend', up).add(node, 'mousemove', move, nonPassiveEvent).add(node, 'mouseup', up);\n  }\n  function isFocusNode(node) {\n    const nodeName = node.nodeName || '';\n    return focusNodes.includes(nodeName);\n  }\n  function forceBoost() {\n    const boost = dragFree ? freeForceBoost : snapForceBoost;\n    const type = isMouse ? 'mouse' : 'touch';\n    return boost[type];\n  }\n  function allowedForce(force, targetChanged) {\n    const next = index.add(mathSign(force) * -1);\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;\n    if (skipSnaps && targetChanged) return baseForce * 0.5;\n    return scrollTarget.byIndex(next.get(), 0).distance;\n  }\n  function down(evt) {\n    const isMouseEvt = isMouseEvent(evt, ownerWindow);\n    isMouse = isMouseEvt;\n    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;\n    isMoving = deltaAbs(target.get(), location.get()) >= 2;\n    if (isMouseEvt && evt.button !== 0) return;\n    if (isFocusNode(evt.target)) return;\n    pointerIsDown = true;\n    dragTracker.pointerDown(evt);\n    scrollBody.useFriction(0).useDuration(0);\n    target.set(location);\n    addDragEvents();\n    startScroll = dragTracker.readPoint(evt);\n    startCross = dragTracker.readPoint(evt, crossAxis);\n    eventHandler.emit('pointerDown');\n  }\n  function move(evt) {\n    const isTouchEvt = !isMouseEvent(evt, ownerWindow);\n    if (isTouchEvt && evt.touches.length >= 2) return up(evt);\n    const lastScroll = dragTracker.readPoint(evt);\n    const lastCross = dragTracker.readPoint(evt, crossAxis);\n    const diffScroll = deltaAbs(lastScroll, startScroll);\n    const diffCross = deltaAbs(lastCross, startCross);\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt);\n      preventScroll = diffScroll > diffCross;\n      if (!preventScroll) return up(evt);\n    }\n    const diff = dragTracker.pointerMove(evt);\n    if (diffScroll > dragThreshold) preventClick = true;\n    scrollBody.useFriction(0.3).useDuration(0.75);\n    animation.start();\n    target.add(direction(diff));\n    evt.preventDefault();\n  }\n  function up(evt) {\n    const currentLocation = scrollTarget.byDistance(0, false);\n    const targetChanged = currentLocation.index !== index.get();\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost();\n    const force = allowedForce(direction(rawForce), targetChanged);\n    const forceFactor = factorAbs(rawForce, force);\n    const speed = baseSpeed - 10 * forceFactor;\n    const friction = baseFriction + forceFactor / 50;\n    preventScroll = false;\n    pointerIsDown = false;\n    dragEvents.clear();\n    scrollBody.useDuration(speed).useFriction(friction);\n    scrollTo.distance(force, !dragFree);\n    isMouse = false;\n    eventHandler.emit('pointerUp');\n  }\n  function click(evt) {\n    if (preventClick) {\n      evt.stopPropagation();\n      evt.preventDefault();\n      preventClick = false;\n    }\n  }\n  function pointerDown() {\n    return pointerIsDown;\n  }\n  const self = {\n    init,\n    destroy,\n    pointerDown\n  };\n  return self;\n}\n\nfunction DragTracker(axis, ownerWindow) {\n  const logInterval = 170;\n  let startEvent;\n  let lastEvent;\n  function readTime(evt) {\n    return evt.timeStamp;\n  }\n  function readPoint(evt, evtAxis) {\n    const property = evtAxis || axis.scroll;\n    const coord = `client${property === 'x' ? 'X' : 'Y'}`;\n    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];\n  }\n  function pointerDown(evt) {\n    startEvent = evt;\n    lastEvent = evt;\n    return readPoint(evt);\n  }\n  function pointerMove(evt) {\n    const diff = readPoint(evt) - readPoint(lastEvent);\n    const expired = readTime(evt) - readTime(startEvent) > logInterval;\n    lastEvent = evt;\n    if (expired) startEvent = evt;\n    return diff;\n  }\n  function pointerUp(evt) {\n    if (!startEvent || !lastEvent) return 0;\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n    const diffTime = readTime(evt) - readTime(startEvent);\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval;\n    const force = diffDrag / diffTime;\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n    return isFlick ? force : 0;\n  }\n  const self = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint\n  };\n  return self;\n}\n\nfunction NodeRects() {\n  function measure(node) {\n    const {\n      offsetTop,\n      offsetLeft,\n      offsetWidth,\n      offsetHeight\n    } = node;\n    const offset = {\n      top: offsetTop,\n      right: offsetLeft + offsetWidth,\n      bottom: offsetTop + offsetHeight,\n      left: offsetLeft,\n      width: offsetWidth,\n      height: offsetHeight\n    };\n    return offset;\n  }\n  const self = {\n    measure\n  };\n  return self;\n}\n\nfunction PercentOfView(viewSize) {\n  function measure(n) {\n    return viewSize * (n / 100);\n  }\n  const self = {\n    measure\n  };\n  return self;\n}\n\nfunction ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {\n  const observeNodes = [container].concat(slides);\n  let resizeObserver;\n  let containerSize;\n  let slideSizes = [];\n  let destroyed = false;\n  function readSize(node) {\n    return axis.measureSize(nodeRects.measure(node));\n  }\n  function init(emblaApi) {\n    if (!watchResize) return;\n    containerSize = readSize(container);\n    slideSizes = slides.map(readSize);\n    function defaultCallback(entries) {\n      for (const entry of entries) {\n        if (destroyed) return;\n        const isContainer = entry.target === container;\n        const slideIndex = slides.indexOf(entry.target);\n        const lastSize = isContainer ? containerSize : slideSizes[slideIndex];\n        const newSize = readSize(isContainer ? container : slides[slideIndex]);\n        const diffSize = mathAbs(newSize - lastSize);\n        if (diffSize >= 0.5) {\n          emblaApi.reInit();\n          eventHandler.emit('resize');\n          break;\n        }\n      }\n    }\n    resizeObserver = new ResizeObserver(entries => {\n      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n        defaultCallback(entries);\n      }\n    });\n    ownerWindow.requestAnimationFrame(() => {\n      observeNodes.forEach(node => resizeObserver.observe(node));\n    });\n  }\n  function destroy() {\n    destroyed = true;\n    if (resizeObserver) resizeObserver.disconnect();\n  }\n  const self = {\n    init,\n    destroy\n  };\n  return self;\n}\n\nfunction ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {\n  let scrollVelocity = 0;\n  let scrollDirection = 0;\n  let scrollDuration = baseDuration;\n  let scrollFriction = baseFriction;\n  let rawLocation = location.get();\n  let rawLocationPrevious = 0;\n  function seek() {\n    const displacement = target.get() - location.get();\n    const isInstant = !scrollDuration;\n    let scrollDistance = 0;\n    if (isInstant) {\n      scrollVelocity = 0;\n      previousLocation.set(target);\n      location.set(target);\n      scrollDistance = displacement;\n    } else {\n      previousLocation.set(location);\n      scrollVelocity += displacement / scrollDuration;\n      scrollVelocity *= scrollFriction;\n      rawLocation += scrollVelocity;\n      location.add(scrollVelocity);\n      scrollDistance = rawLocation - rawLocationPrevious;\n    }\n    scrollDirection = mathSign(scrollDistance);\n    rawLocationPrevious = rawLocation;\n    return self;\n  }\n  function settled() {\n    const diff = target.get() - offsetLocation.get();\n    return mathAbs(diff) < 0.001;\n  }\n  function duration() {\n    return scrollDuration;\n  }\n  function direction() {\n    return scrollDirection;\n  }\n  function velocity() {\n    return scrollVelocity;\n  }\n  function useBaseDuration() {\n    return useDuration(baseDuration);\n  }\n  function useBaseFriction() {\n    return useFriction(baseFriction);\n  }\n  function useDuration(n) {\n    scrollDuration = n;\n    return self;\n  }\n  function useFriction(n) {\n    scrollFriction = n;\n    return self;\n  }\n  const self = {\n    direction,\n    duration,\n    velocity,\n    seek,\n    settled,\n    useBaseFriction,\n    useBaseDuration,\n    useFriction,\n    useDuration\n  };\n  return self;\n}\n\nfunction ScrollBounds(limit, location, target, scrollBody, percentOfView) {\n  const pullBackThreshold = percentOfView.measure(10);\n  const edgeOffsetTolerance = percentOfView.measure(50);\n  const frictionLimit = Limit(0.1, 0.99);\n  let disabled = false;\n  function shouldConstrain() {\n    if (disabled) return false;\n    if (!limit.reachedAny(target.get())) return false;\n    if (!limit.reachedAny(location.get())) return false;\n    return true;\n  }\n  function constrain(pointerDown) {\n    if (!shouldConstrain()) return;\n    const edge = limit.reachedMin(location.get()) ? 'min' : 'max';\n    const diffToEdge = mathAbs(limit[edge] - location.get());\n    const diffToTarget = target.get() - location.get();\n    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);\n    target.subtract(diffToTarget * friction);\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()));\n      scrollBody.useDuration(25).useBaseFriction();\n    }\n  }\n  function toggleActive(active) {\n    disabled = !active;\n  }\n  const self = {\n    shouldConstrain,\n    constrain,\n    toggleActive\n  };\n  return self;\n}\n\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {\n  const scrollBounds = Limit(-contentSize + viewSize, 0);\n  const snapsBounded = measureBounded();\n  const scrollContainLimit = findScrollContainLimit();\n  const snapsContained = measureContained();\n  function usePixelTolerance(bound, snap) {\n    return deltaAbs(bound, snap) <= 1;\n  }\n  function findScrollContainLimit() {\n    const startSnap = snapsBounded[0];\n    const endSnap = arrayLast(snapsBounded);\n    const min = snapsBounded.lastIndexOf(startSnap);\n    const max = snapsBounded.indexOf(endSnap) + 1;\n    return Limit(min, max);\n  }\n  function measureBounded() {\n    return snapsAligned.map((snapAligned, index) => {\n      const {\n        min,\n        max\n      } = scrollBounds;\n      const snap = scrollBounds.constrain(snapAligned);\n      const isFirst = !index;\n      const isLast = arrayIsLastIndex(snapsAligned, index);\n      if (isFirst) return max;\n      if (isLast) return min;\n      if (usePixelTolerance(min, snap)) return min;\n      if (usePixelTolerance(max, snap)) return max;\n      return snap;\n    }).map(scrollBound => parseFloat(scrollBound.toFixed(3)));\n  }\n  function measureContained() {\n    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max];\n    if (containScroll === 'keepSnaps') return snapsBounded;\n    const {\n      min,\n      max\n    } = scrollContainLimit;\n    return snapsBounded.slice(min, max);\n  }\n  const self = {\n    snapsContained,\n    scrollContainLimit\n  };\n  return self;\n}\n\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n  const max = scrollSnaps[0];\n  const min = loop ? max - contentSize : arrayLast(scrollSnaps);\n  const limit = Limit(min, max);\n  const self = {\n    limit\n  };\n  return self;\n}\n\nfunction ScrollLooper(contentSize, limit, location, vectors) {\n  const jointSafety = 0.1;\n  const min = limit.min + jointSafety;\n  const max = limit.max + jointSafety;\n  const {\n    reachedMin,\n    reachedMax\n  } = Limit(min, max);\n  function shouldLoop(direction) {\n    if (direction === 1) return reachedMax(location.get());\n    if (direction === -1) return reachedMin(location.get());\n    return false;\n  }\n  function loop(direction) {\n    if (!shouldLoop(direction)) return;\n    const loopDistance = contentSize * (direction * -1);\n    vectors.forEach(v => v.add(loopDistance));\n  }\n  const self = {\n    loop\n  };\n  return self;\n}\n\nfunction ScrollProgress(limit) {\n  const {\n    max,\n    length\n  } = limit;\n  function get(n) {\n    const currentLocation = n - max;\n    return length ? currentLocation / -length : 0;\n  }\n  const self = {\n    get\n  };\n  return self;\n}\n\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {\n  const {\n    startEdge,\n    endEdge\n  } = axis;\n  const {\n    groupSlides\n  } = slidesToScroll;\n  const alignments = measureSizes().map(alignment.measure);\n  const snaps = measureUnaligned();\n  const snapsAligned = measureAligned();\n  function measureSizes() {\n    return groupSlides(slideRects).map(rects => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);\n  }\n  function measureUnaligned() {\n    return slideRects.map(rect => containerRect[startEdge] - rect[startEdge]).map(snap => -mathAbs(snap));\n  }\n  function measureAligned() {\n    return groupSlides(snaps).map(g => g[0]).map((snap, index) => snap + alignments[index]);\n  }\n  const self = {\n    snaps,\n    snapsAligned\n  };\n  return self;\n}\n\nfunction SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {\n  const {\n    groupSlides\n  } = slidesToScroll;\n  const {\n    min,\n    max\n  } = scrollContainLimit;\n  const slideRegistry = createSlideRegistry();\n  function createSlideRegistry() {\n    const groupedSlideIndexes = groupSlides(slideIndexes);\n    const doNotContain = !containSnaps || containScroll === 'keepSnaps';\n    if (scrollSnaps.length === 1) return [slideIndexes];\n    if (doNotContain) return groupedSlideIndexes;\n    return groupedSlideIndexes.slice(min, max).map((group, index, groups) => {\n      const isFirst = !index;\n      const isLast = arrayIsLastIndex(groups, index);\n      if (isFirst) {\n        const range = arrayLast(groups[0]) + 1;\n        return arrayFromNumber(range);\n      }\n      if (isLast) {\n        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;\n        return arrayFromNumber(range, arrayLast(groups)[0]);\n      }\n      return group;\n    });\n  }\n  const self = {\n    slideRegistry\n  };\n  return self;\n}\n\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n  const {\n    reachedAny,\n    removeOffset,\n    constrain\n  } = limit;\n  function minDistance(distances) {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0];\n  }\n  function findTargetSnap(target) {\n    const distance = loop ? removeOffset(target) : constrain(target);\n    const ascDiffsToSnaps = scrollSnaps.map((snap, index) => ({\n      diff: shortcut(snap - distance, 0),\n      index\n    })).sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff));\n    const {\n      index\n    } = ascDiffsToSnaps[0];\n    return {\n      index,\n      distance\n    };\n  }\n  function shortcut(target, direction) {\n    const targets = [target, target + contentSize, target - contentSize];\n    if (!loop) return target;\n    if (!direction) return minDistance(targets);\n    const matchingTargets = targets.filter(t => mathSign(t) === direction);\n    if (matchingTargets.length) return minDistance(matchingTargets);\n    return arrayLast(targets) - contentSize;\n  }\n  function byIndex(index, direction) {\n    const diffToSnap = scrollSnaps[index] - targetVector.get();\n    const distance = shortcut(diffToSnap, direction);\n    return {\n      index,\n      distance\n    };\n  }\n  function byDistance(distance, snap) {\n    const target = targetVector.get() + distance;\n    const {\n      index,\n      distance: targetSnapDistance\n    } = findTargetSnap(target);\n    const reachedBound = !loop && reachedAny(target);\n    if (!snap || reachedBound) return {\n      index,\n      distance\n    };\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance;\n    const snapDistance = distance + shortcut(diffToSnap, 0);\n    return {\n      index,\n      distance: snapDistance\n    };\n  }\n  const self = {\n    byDistance,\n    byIndex,\n    shortcut\n  };\n  return self;\n}\n\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {\n  function scrollTo(target) {\n    const distanceDiff = target.distance;\n    const indexDiff = target.index !== indexCurrent.get();\n    targetVector.add(distanceDiff);\n    if (distanceDiff) {\n      if (scrollBody.duration()) {\n        animation.start();\n      } else {\n        animation.update();\n        animation.render(1);\n        animation.update();\n      }\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get());\n      indexCurrent.set(target.index);\n      eventHandler.emit('select');\n    }\n  }\n  function distance(n, snap) {\n    const target = scrollTarget.byDistance(n, snap);\n    scrollTo(target);\n  }\n  function index(n, direction) {\n    const targetIndex = indexCurrent.clone().set(n);\n    const target = scrollTarget.byIndex(targetIndex.get(), direction);\n    scrollTo(target);\n  }\n  const self = {\n    distance,\n    index\n  };\n  return self;\n}\n\nfunction SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {\n  const focusListenerOptions = {\n    passive: true,\n    capture: true\n  };\n  let lastTabPressTime = 0;\n  function init(emblaApi) {\n    if (!watchFocus) return;\n    function defaultCallback(index) {\n      const nowTime = new Date().getTime();\n      const diffTime = nowTime - lastTabPressTime;\n      if (diffTime > 10) return;\n      eventHandler.emit('slideFocusStart');\n      root.scrollLeft = 0;\n      const group = slideRegistry.findIndex(group => group.includes(index));\n      if (!isNumber(group)) return;\n      scrollBody.useDuration(0);\n      scrollTo.index(group, 0);\n      eventHandler.emit('slideFocus');\n    }\n    eventStore.add(document, 'keydown', registerTabPress, false);\n    slides.forEach((slide, slideIndex) => {\n      eventStore.add(slide, 'focus', evt => {\n        if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {\n          defaultCallback(slideIndex);\n        }\n      }, focusListenerOptions);\n    });\n  }\n  function registerTabPress(event) {\n    if (event.code === 'Tab') lastTabPressTime = new Date().getTime();\n  }\n  const self = {\n    init\n  };\n  return self;\n}\n\nfunction Vector1D(initialValue) {\n  let value = initialValue;\n  function get() {\n    return value;\n  }\n  function set(n) {\n    value = normalizeInput(n);\n  }\n  function add(n) {\n    value += normalizeInput(n);\n  }\n  function subtract(n) {\n    value -= normalizeInput(n);\n  }\n  function normalizeInput(n) {\n    return isNumber(n) ? n : n.get();\n  }\n  const self = {\n    get,\n    set,\n    add,\n    subtract\n  };\n  return self;\n}\n\nfunction Translate(axis, container) {\n  const translate = axis.scroll === 'x' ? x : y;\n  const containerStyle = container.style;\n  let previousTarget = null;\n  let disabled = false;\n  function x(n) {\n    return `translate3d(${n}px,0px,0px)`;\n  }\n  function y(n) {\n    return `translate3d(0px,${n}px,0px)`;\n  }\n  function to(target) {\n    if (disabled) return;\n    const newTarget = roundToTwoDecimals(axis.direction(target));\n    if (newTarget === previousTarget) return;\n    containerStyle.transform = translate(newTarget);\n    previousTarget = newTarget;\n  }\n  function toggleActive(active) {\n    disabled = !active;\n  }\n  function clear() {\n    if (disabled) return;\n    containerStyle.transform = '';\n    if (!container.getAttribute('style')) container.removeAttribute('style');\n  }\n  const self = {\n    clear,\n    to,\n    toggleActive\n  };\n  return self;\n}\n\nfunction SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location, slides) {\n  const roundingSafety = 0.5;\n  const ascItems = arrayKeys(slideSizesWithGaps);\n  const descItems = arrayKeys(slideSizesWithGaps).reverse();\n  const loopPoints = startPoints().concat(endPoints());\n  function removeSlideSizes(indexes, from) {\n    return indexes.reduce((a, i) => {\n      return a - slideSizesWithGaps[i];\n    }, from);\n  }\n  function slidesInGap(indexes, gap) {\n    return indexes.reduce((a, i) => {\n      const remainingGap = removeSlideSizes(a, gap);\n      return remainingGap > 0 ? a.concat([i]) : a;\n    }, []);\n  }\n  function findSlideBounds(offset) {\n    return snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + roundingSafety + offset,\n      end: snap + viewSize - roundingSafety + offset\n    }));\n  }\n  function findLoopPoints(indexes, offset, isEndEdge) {\n    const slideBounds = findSlideBounds(offset);\n    return indexes.map(index => {\n      const initial = isEndEdge ? 0 : -contentSize;\n      const altered = isEndEdge ? contentSize : 0;\n      const boundEdge = isEndEdge ? 'end' : 'start';\n      const loopPoint = slideBounds[index][boundEdge];\n      return {\n        index,\n        loopPoint,\n        slideLocation: Vector1D(-1),\n        translate: Translate(axis, slides[index]),\n        target: () => location.get() > loopPoint ? initial : altered\n      };\n    });\n  }\n  function startPoints() {\n    const gap = scrollSnaps[0];\n    const indexes = slidesInGap(descItems, gap);\n    return findLoopPoints(indexes, contentSize, false);\n  }\n  function endPoints() {\n    const gap = viewSize - scrollSnaps[0] - 1;\n    const indexes = slidesInGap(ascItems, gap);\n    return findLoopPoints(indexes, -contentSize, true);\n  }\n  function canLoop() {\n    return loopPoints.every(({\n      index\n    }) => {\n      const otherIndexes = ascItems.filter(i => i !== index);\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n    });\n  }\n  function loop() {\n    loopPoints.forEach(loopPoint => {\n      const {\n        target,\n        translate,\n        slideLocation\n      } = loopPoint;\n      const shiftLocation = target();\n      if (shiftLocation === slideLocation.get()) return;\n      translate.to(shiftLocation);\n      slideLocation.set(shiftLocation);\n    });\n  }\n  function clear() {\n    loopPoints.forEach(loopPoint => loopPoint.translate.clear());\n  }\n  const self = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints\n  };\n  return self;\n}\n\nfunction SlidesHandler(container, eventHandler, watchSlides) {\n  let mutationObserver;\n  let destroyed = false;\n  function init(emblaApi) {\n    if (!watchSlides) return;\n    function defaultCallback(mutations) {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList') {\n          emblaApi.reInit();\n          eventHandler.emit('slidesChanged');\n          break;\n        }\n      }\n    }\n    mutationObserver = new MutationObserver(mutations => {\n      if (destroyed) return;\n      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n        defaultCallback(mutations);\n      }\n    });\n    mutationObserver.observe(container, {\n      childList: true\n    });\n  }\n  function destroy() {\n    if (mutationObserver) mutationObserver.disconnect();\n    destroyed = true;\n  }\n  const self = {\n    init,\n    destroy\n  };\n  return self;\n}\n\nfunction SlidesInView(container, slides, eventHandler, threshold) {\n  const intersectionEntryMap = {};\n  let inViewCache = null;\n  let notInViewCache = null;\n  let intersectionObserver;\n  let destroyed = false;\n  function init() {\n    intersectionObserver = new IntersectionObserver(entries => {\n      if (destroyed) return;\n      entries.forEach(entry => {\n        const index = slides.indexOf(entry.target);\n        intersectionEntryMap[index] = entry;\n      });\n      inViewCache = null;\n      notInViewCache = null;\n      eventHandler.emit('slidesInView');\n    }, {\n      root: container.parentElement,\n      threshold\n    });\n    slides.forEach(slide => intersectionObserver.observe(slide));\n  }\n  function destroy() {\n    if (intersectionObserver) intersectionObserver.disconnect();\n    destroyed = true;\n  }\n  function createInViewList(inView) {\n    return objectKeys(intersectionEntryMap).reduce((list, slideIndex) => {\n      const index = parseInt(slideIndex);\n      const {\n        isIntersecting\n      } = intersectionEntryMap[index];\n      const inViewMatch = inView && isIntersecting;\n      const notInViewMatch = !inView && !isIntersecting;\n      if (inViewMatch || notInViewMatch) list.push(index);\n      return list;\n    }, []);\n  }\n  function get(inView = true) {\n    if (inView && inViewCache) return inViewCache;\n    if (!inView && notInViewCache) return notInViewCache;\n    const slideIndexes = createInViewList(inView);\n    if (inView) inViewCache = slideIndexes;\n    if (!inView) notInViewCache = slideIndexes;\n    return slideIndexes;\n  }\n  const self = {\n    init,\n    destroy,\n    get\n  };\n  return self;\n}\n\nfunction SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {\n  const {\n    measureSize,\n    startEdge,\n    endEdge\n  } = axis;\n  const withEdgeGap = slideRects[0] && readEdgeGap;\n  const startGap = measureStartGap();\n  const endGap = measureEndGap();\n  const slideSizes = slideRects.map(measureSize);\n  const slideSizesWithGaps = measureWithGaps();\n  function measureStartGap() {\n    if (!withEdgeGap) return 0;\n    const slideRect = slideRects[0];\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n  }\n  function measureEndGap() {\n    if (!withEdgeGap) return 0;\n    const style = ownerWindow.getComputedStyle(arrayLast(slides));\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`));\n  }\n  function measureWithGaps() {\n    return slideRects.map((rect, index, rects) => {\n      const isFirst = !index;\n      const isLast = arrayIsLastIndex(rects, index);\n      if (isFirst) return slideSizes[index] + startGap;\n      if (isLast) return slideSizes[index] + endGap;\n      return rects[index + 1][startEdge] - rect[startEdge];\n    }).map(mathAbs);\n  }\n  const self = {\n    slideSizes,\n    slideSizesWithGaps,\n    startGap,\n    endGap\n  };\n  return self;\n}\n\nfunction SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {\n  const {\n    startEdge,\n    endEdge,\n    direction\n  } = axis;\n  const groupByNumber = isNumber(slidesToScroll);\n  function byNumber(array, groupSize) {\n    return arrayKeys(array).filter(i => i % groupSize === 0).map(i => array.slice(i, i + groupSize));\n  }\n  function bySize(array) {\n    if (!array.length) return [];\n    return arrayKeys(array).reduce((groups, rectB, index) => {\n      const rectA = arrayLast(groups) || 0;\n      const isFirst = rectA === 0;\n      const isLast = rectB === arrayLastIndex(array);\n      const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];\n      const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];\n      const gapA = !loop && isFirst ? direction(startGap) : 0;\n      const gapB = !loop && isLast ? direction(endGap) : 0;\n      const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));\n      if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB);\n      if (isLast) groups.push(array.length);\n      return groups;\n    }, []).map((currentSize, index, groups) => {\n      const previousSize = Math.max(groups[index - 1] || 0);\n      return array.slice(previousSize, currentSize);\n    });\n  }\n  function groupSlides(array) {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n  }\n  const self = {\n    groupSlides\n  };\n  return self;\n}\n\nfunction Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction,\n    startIndex,\n    loop,\n    duration,\n    dragFree,\n    dragThreshold,\n    inViewThreshold,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n    watchResize,\n    watchSlides,\n    watchDrag,\n    watchFocus\n  } = options;\n  // Measurements\n  const pixelTolerance = 2;\n  const nodeRects = NodeRects();\n  const containerRect = nodeRects.measure(container);\n  const slideRects = slides.map(nodeRects.measure);\n  const axis = Axis(scrollAxis, direction);\n  const viewSize = axis.measureSize(containerRect);\n  const percentOfView = PercentOfView(viewSize);\n  const alignment = Alignment(align, viewSize);\n  const containSnaps = !loop && !!containScroll;\n  const readEdgeGap = loop || !!containScroll;\n  const {\n    slideSizes,\n    slideSizesWithGaps,\n    startGap,\n    endGap\n  } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);\n  const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);\n  const {\n    snaps,\n    snapsAligned\n  } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n  const {\n    snapsContained,\n    scrollContainLimit\n  } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n  const {\n    limit\n  } = ScrollLimit(contentSize, scrollSnaps, loop);\n  // Indexes\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n  const indexPrevious = index.clone();\n  const slideIndexes = arrayKeys(slides);\n  // Animation\n  const update = ({\n    dragHandler,\n    scrollBody,\n    scrollBounds,\n    options: {\n      loop\n    }\n  }) => {\n    if (!loop) scrollBounds.constrain(dragHandler.pointerDown());\n    scrollBody.seek();\n  };\n  const render = ({\n    scrollBody,\n    translate,\n    location,\n    offsetLocation,\n    previousLocation,\n    scrollLooper,\n    slideLooper,\n    dragHandler,\n    animation,\n    eventHandler,\n    scrollBounds,\n    options: {\n      loop\n    }\n  }, alpha) => {\n    const shouldSettle = scrollBody.settled();\n    const withinBounds = !scrollBounds.shouldConstrain();\n    const hasSettled = loop ? shouldSettle : shouldSettle && withinBounds;\n    if (hasSettled && !dragHandler.pointerDown()) {\n      animation.stop();\n      eventHandler.emit('settle');\n    }\n    if (!hasSettled) eventHandler.emit('scroll');\n    const interpolatedLocation = location.get() * alpha + previousLocation.get() * (1 - alpha);\n    offsetLocation.set(interpolatedLocation);\n    if (loop) {\n      scrollLooper.loop(scrollBody.direction());\n      slideLooper.loop();\n    }\n    translate.to(offsetLocation.get());\n  };\n  const animation = Animations(ownerDocument, ownerWindow, () => update(engine), alpha => render(engine, alpha));\n  // Shared\n  const friction = 0.68;\n  const startLocation = scrollSnaps[index.get()];\n  const location = Vector1D(startLocation);\n  const previousLocation = Vector1D(startLocation);\n  const offsetLocation = Vector1D(startLocation);\n  const target = Vector1D(startLocation);\n  const scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction);\n  const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n  const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);\n  const scrollProgress = ScrollProgress(limit);\n  const eventStore = EventStore();\n  const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);\n  const {\n    slideRegistry\n  } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);\n  const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);\n  // Engine\n  const engine = {\n    ownerDocument,\n    ownerWindow,\n    eventHandler,\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),\n    eventStore,\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    offsetLocation,\n    previousLocation,\n    options,\n    resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),\n    scrollBody,\n    scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),\n    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [location, offsetLocation, previousLocation, target]),\n    scrollProgress,\n    scrollSnapList: scrollSnaps.map(scrollProgress.get),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),\n    slideFocus,\n    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n    slidesInView,\n    slideIndexes,\n    slideRegistry,\n    slidesToScroll,\n    target,\n    translate: Translate(axis, container)\n  };\n  return engine;\n}\n\nfunction EventHandler() {\n  let listeners = {};\n  let api;\n  function init(emblaApi) {\n    api = emblaApi;\n  }\n  function getListeners(evt) {\n    return listeners[evt] || [];\n  }\n  function emit(evt) {\n    getListeners(evt).forEach(e => e(api, evt));\n    return self;\n  }\n  function on(evt, cb) {\n    listeners[evt] = getListeners(evt).concat([cb]);\n    return self;\n  }\n  function off(evt, cb) {\n    listeners[evt] = getListeners(evt).filter(e => e !== cb);\n    return self;\n  }\n  function clear() {\n    listeners = {};\n  }\n  const self = {\n    init,\n    emit,\n    off,\n    on,\n    clear\n  };\n  return self;\n}\n\nconst defaultOptions = {\n  align: 'center',\n  axis: 'x',\n  container: null,\n  slides: null,\n  containScroll: 'trimSnaps',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  inViewThreshold: 0,\n  breakpoints: {},\n  dragFree: false,\n  dragThreshold: 10,\n  loop: false,\n  skipSnaps: false,\n  duration: 25,\n  startIndex: 0,\n  active: true,\n  watchDrag: true,\n  watchResize: true,\n  watchSlides: true,\n  watchFocus: true\n};\n\nfunction OptionsHandler(ownerWindow) {\n  function mergeOptions(optionsA, optionsB) {\n    return objectsMergeDeep(optionsA, optionsB || {});\n  }\n  function optionsAtMedia(options) {\n    const optionsAtMedia = options.breakpoints || {};\n    const matchedMediaOptions = objectKeys(optionsAtMedia).filter(media => ownerWindow.matchMedia(media).matches).map(media => optionsAtMedia[media]).reduce((a, mediaOption) => mergeOptions(a, mediaOption), {});\n    return mergeOptions(options, matchedMediaOptions);\n  }\n  function optionsMediaQueries(optionsList) {\n    return optionsList.map(options => objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries) => acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);\n  }\n  const self = {\n    mergeOptions,\n    optionsAtMedia,\n    optionsMediaQueries\n  };\n  return self;\n}\n\nfunction PluginsHandler(optionsHandler) {\n  let activePlugins = [];\n  function init(emblaApi, plugins) {\n    activePlugins = plugins.filter(({\n      options\n    }) => optionsHandler.optionsAtMedia(options).active !== false);\n    activePlugins.forEach(plugin => plugin.init(emblaApi, optionsHandler));\n    return plugins.reduce((map, plugin) => Object.assign(map, {\n      [plugin.name]: plugin\n    }), {});\n  }\n  function destroy() {\n    activePlugins = activePlugins.filter(plugin => plugin.destroy());\n  }\n  const self = {\n    init,\n    destroy\n  };\n  return self;\n}\n\nfunction EmblaCarousel(root, userOptions, userPlugins) {\n  const ownerDocument = root.ownerDocument;\n  const ownerWindow = ownerDocument.defaultView;\n  const optionsHandler = OptionsHandler(ownerWindow);\n  const pluginsHandler = PluginsHandler(optionsHandler);\n  const mediaHandlers = EventStore();\n  const eventHandler = EventHandler();\n  const {\n    mergeOptions,\n    optionsAtMedia,\n    optionsMediaQueries\n  } = optionsHandler;\n  const {\n    on,\n    off,\n    emit\n  } = eventHandler;\n  const reInit = reActivate;\n  let destroyed = false;\n  let engine;\n  let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);\n  let options = mergeOptions(optionsBase);\n  let pluginList = [];\n  let pluginApis;\n  let container;\n  let slides;\n  function storeElements() {\n    const {\n      container: userContainer,\n      slides: userSlides\n    } = options;\n    const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;\n    container = customContainer || root.children[0];\n    const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;\n    slides = [].slice.call(customSlides || container.children);\n  }\n  function createEngine(options) {\n    const engine = Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler);\n    if (options.loop && !engine.slideLooper.canLoop()) {\n      const optionsWithoutLoop = Object.assign({}, options, {\n        loop: false\n      });\n      return createEngine(optionsWithoutLoop);\n    }\n    return engine;\n  }\n  function activate(withOptions, withPlugins) {\n    if (destroyed) return;\n    optionsBase = mergeOptions(optionsBase, withOptions);\n    options = optionsAtMedia(optionsBase);\n    pluginList = withPlugins || pluginList;\n    storeElements();\n    engine = createEngine(options);\n    optionsMediaQueries([optionsBase, ...pluginList.map(({\n      options\n    }) => options)]).forEach(query => mediaHandlers.add(query, 'change', reActivate));\n    if (!options.active) return;\n    engine.translate.to(engine.location.get());\n    engine.animation.init();\n    engine.slidesInView.init();\n    engine.slideFocus.init(self);\n    engine.eventHandler.init(self);\n    engine.resizeHandler.init(self);\n    engine.slidesHandler.init(self);\n    if (engine.options.loop) engine.slideLooper.loop();\n    if (container.offsetParent && slides.length) engine.dragHandler.init(self);\n    pluginApis = pluginsHandler.init(self, pluginList);\n  }\n  function reActivate(withOptions, withPlugins) {\n    const startIndex = selectedScrollSnap();\n    deActivate();\n    activate(mergeOptions({\n      startIndex\n    }, withOptions), withPlugins);\n    eventHandler.emit('reInit');\n  }\n  function deActivate() {\n    engine.dragHandler.destroy();\n    engine.eventStore.clear();\n    engine.translate.clear();\n    engine.slideLooper.clear();\n    engine.resizeHandler.destroy();\n    engine.slidesHandler.destroy();\n    engine.slidesInView.destroy();\n    engine.animation.destroy();\n    pluginsHandler.destroy();\n    mediaHandlers.clear();\n  }\n  function destroy() {\n    if (destroyed) return;\n    destroyed = true;\n    mediaHandlers.clear();\n    deActivate();\n    eventHandler.emit('destroy');\n    eventHandler.clear();\n  }\n  function scrollTo(index, jump, direction) {\n    if (!options.active || destroyed) return;\n    engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);\n    engine.scrollTo.index(index, direction || 0);\n  }\n  function scrollNext(jump) {\n    const next = engine.index.add(1).get();\n    scrollTo(next, jump, -1);\n  }\n  function scrollPrev(jump) {\n    const prev = engine.index.add(-1).get();\n    scrollTo(prev, jump, 1);\n  }\n  function canScrollNext() {\n    const next = engine.index.add(1).get();\n    return next !== selectedScrollSnap();\n  }\n  function canScrollPrev() {\n    const prev = engine.index.add(-1).get();\n    return prev !== selectedScrollSnap();\n  }\n  function scrollSnapList() {\n    return engine.scrollSnapList;\n  }\n  function scrollProgress() {\n    return engine.scrollProgress.get(engine.location.get());\n  }\n  function selectedScrollSnap() {\n    return engine.index.get();\n  }\n  function previousScrollSnap() {\n    return engine.indexPrevious.get();\n  }\n  function slidesInView() {\n    return engine.slidesInView.get();\n  }\n  function slidesNotInView() {\n    return engine.slidesInView.get(false);\n  }\n  function plugins() {\n    return pluginApis;\n  }\n  function internalEngine() {\n    return engine;\n  }\n  function rootNode() {\n    return root;\n  }\n  function containerNode() {\n    return container;\n  }\n  function slideNodes() {\n    return slides;\n  }\n  const self = {\n    canScrollNext,\n    canScrollPrev,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    emit,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView\n  };\n  activate(userOptions, userPlugins);\n  setTimeout(() => eventHandler.emit('init'), 0);\n  return self;\n}\nEmblaCarousel.globalOptions = undefined;\n\nexport { EmblaCarousel as default };\n//# sourceMappingURL=embla-carousel.esm.js.map\n"],"names":["isNumber","subject","isString","isBoolean","isObject","Object","prototype","toString","call","mathAbs","n","Math","abs","mathSign","sign","deltaAbs","valueB","valueA","arrayKeys","array","objectKeys","map","Number","arrayLast","arrayLastIndex","max","length","arrayIsLastIndex","index","arrayFromNumber","startAt","Array","from","_","i","object","keys","objectsMergeDeep","objectA","objectB","reduce","mergedObjects","currentObject","forEach","key","areObjects","isMouseEvent","evt","ownerWindow","MouseEvent","EventStore","listeners","self","add","node","type","handler","options","passive","removeListener","addEventListener","removeEventListener","legacyMediaQueryList","addListener","push","clear","filter","remove","Animations","ownerDocument","update","render","documentVisibleHandler","fixedTimeStep","lastTimeStamp","accumulatedTime","animationId","animate","timeStamp","timeElapsed","requestAnimationFrame","stop","cancelAnimationFrame","init","hidden","destroy","start","Limit","min","reachedMin","reachedMax","reachedAny","constrain","removeOffset","ceil","Counter","loop","loopEnd","counter","withinLimit","get","clone","set","DragHandler","axis","rootNode","target","dragTracker","location","animation","scrollTo","scrollBody","scrollTarget","eventHandler","percentOfView","dragFree","dragThreshold","skipSnaps","baseFriction","watchDrag","cross","crossAxis","direction","focusNodes","nonPassiveEvent","initEvents","dragEvents","goToNextThreshold","measure","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","isMoving","startScroll","startCross","pointerIsDown","preventScroll","preventClick","isMouse","move","touches","up","lastScroll","readPoint","lastCross","diffScroll","diffCross","cancelable","diff","pointerMove","useFriction","useDuration","preventDefault","targetChanged","byDistance","rawForce","pointerUp","force","next","baseForce","distance","byIndex","allowedForce","forceFactor","factorAbs","speed","friction","emit","click","stopPropagation","emblaApi","downIfAllowed","isMouseEvt","buttons","button","nodeName","includes","isFocusNode","pointerDown","addDragEvents","down","DragTracker","startEvent","lastEvent","readTime","evtAxis","coord","scroll","expired","diffDrag","diffTime","ResizeHandler","container","slides","watchResize","nodeRects","observeNodes","concat","resizeObserver","containerSize","slideSizes","destroyed","readSize","measureSize","ResizeObserver","entries","entry","isContainer","slideIndex","indexOf","lastSize","reInit","defaultCallback","observe","disconnect","ScrollBounds","limit","pullBackThreshold","edgeOffsetTolerance","frictionLimit","disabled","shouldConstrain","edge","diffToEdge","diffToTarget","subtract","useBaseFriction","toggleActive","active","ScrollLooper","contentSize","vectors","shouldLoop","loopDistance","v","ScrollTarget","scrollSnaps","targetVector","minDistance","distances","sort","a","b","shortcut","targets","matchingTargets","t","snap","targetSnapDistance","ascDiffsToSnaps","d1","d2","findTargetSnap","reachedBound","SlideFocus","root","slideRegistry","eventStore","watchFocus","focusListenerOptions","capture","lastTabPressTime","registerTabPress","event","code","Date","getTime","document","slide","scrollLeft","group","findIndex","Vector1D","initialValue","value","normalizeInput","Translate","translate","containerStyle","style","previousTarget","transform","getAttribute","removeAttribute","to","newTarget","num","round","SlideLooper","viewSize","slideSizesWithGaps","snaps","ascItems","descItems","reverse","loopPoints","gap","findLoopPoints","slidesInGap","startPoints","endPoints","removeSlideSizes","indexes","offset","isEndEdge","slideBounds","end","findSlideBounds","initial","altered","boundEdge","loopPoint","slideLocation","canLoop","every","shiftLocation","SlidesHandler","watchSlides","mutationObserver","MutationObserver","mutations","mutation","childList","SlidesInView","threshold","intersectionEntryMap","intersectionObserver","inViewCache","notInViewCache","IntersectionObserver","parentElement","inView","slideIndexes","list","parseInt","isIntersecting","createInViewList","SlidesToScroll","slidesToScroll","containerRect","slideRects","startGap","endGap","pixelTolerance","startEdge","endEdge","groupByNumber","groupSlides","groupSize","slice","byNumber","groups","rectB","rectA","isFirst","isLast","edgeA","edgeB","gapA","chunkSize","currentSize","previousSize","bySize","Engine","align","scrollAxis","startIndex","duration","inViewThreshold","containScroll","offsetTop","offsetLeft","offsetWidth","offsetHeight","top","right","bottom","left","width","height","contentDirection","isRightToLeft","isVertical","nodeRect","Axis","PercentOfView","alignment","predefined","center","Alignment","containSnaps","readEdgeGap","withEdgeGap","slideRect","measureStartGap","getComputedStyle","parseFloat","getPropertyValue","measureEndGap","rect","rects","SlideSizes","snapsAligned","alignments","g","ScrollSnaps","snapsContained","scrollContainLimit","scrollBounds","snapsBounded","snapAligned","usePixelTolerance","scrollBound","toFixed","startSnap","endSnap","lastIndexOf","findScrollContainLimit","bound","measureContained","ScrollContain","ScrollLimit","indexPrevious","dragHandler","seek","engine","alpha","offsetLocation","previousLocation","scrollLooper","slideLooper","shouldSettle","settled","withinBounds","hasSettled","interpolatedLocation","startLocation","baseDuration","scrollVelocity","scrollDirection","scrollDuration","scrollFriction","rawLocation","rawLocationPrevious","velocity","displacement","scrollDistance","useBaseDuration","ScrollBody","indexCurrent","distanceDiff","indexDiff","targetIndex","ScrollTo","scrollProgress","ScrollProgress","slidesInView","groupedSlideIndexes","doNotContain","createSlideRegistry","SlideRegistry","slideFocus","resizeHandler","scrollSnapList","slidesHandler","defaultOptions","breakpoints","OptionsHandler","mergeOptions","optionsA","optionsB","optionsAtMedia","matchedMediaOptions","media","matchMedia","matches","mediaOption","optionsMediaQueries","optionsList","acc","mediaQueries","EmblaCarousel","userOptions","userPlugins","defaultView","optionsHandler","pluginsHandler","activePlugins","plugins","plugin","assign","name","PluginsHandler","mediaHandlers","api","getListeners","e","off","cb","on","EventHandler","reActivate","pluginApis","optionsBase","globalOptions","pluginList","createEngine","activate","withOptions","withPlugins","userContainer","userSlides","customContainer","querySelector","children","customSlides","querySelectorAll","storeElements","query","offsetParent","selectedScrollSnap","deActivate","jump","canScrollNext","canScrollPrev","containerNode","internalEngine","previousScrollSnap","scrollNext","scrollPrev","slideNodes","slidesNotInView","setTimeout","undefined"],"mappings":"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","x_google_ignoreList":[0]}