{"version":3,"file":"vendor--mdast-util-gfm-task-list-item.DlkyJv2w.js","sources":["../../../../node_modules/mdast-util-gfm-task-list-item/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {ok as assert} from 'devlop'\nimport {defaultHandlers} from 'mdast-util-to-markdown'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\n * list items in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemFromMarkdown() {\n  return {\n    exit: {\n      taskListCheckValueChecked: exitCheck,\n      taskListCheckValueUnchecked: exitCheck,\n      paragraph: exitParagraphWithTaskListItem\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\n * items in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemToMarkdown() {\n  return {\n    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n    handlers: {listItem: listItemWithTaskListItem}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  // Weâ€™re always in a paragraph, in a list item.\n  const node = this.stack[this.stack.length - 2]\n  assert(node.type === 'listItem')\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = this.stack[this.stack.length - 2]\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'paragraph')\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, state, info) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = state.createTracker(info)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = defaultHandlers.listItem(node, parent, state, {\n    ...info,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n"],"names":["gfmTaskListItemFromMarkdown","exit","taskListCheckValueChecked","exitCheck","taskListCheckValueUnchecked","paragraph","exitParagraphWithTaskListItem","gfmTaskListItemToMarkdown","unsafe","atBreak","character","after","handlers","listItem","listItemWithTaskListItem","token","node","this","stack","length","assert","type","checked","parent","head","children","siblings","firstParaghraph","index","sibling","value","slice","shift","position","start","offset","column","Object","assign","state","info","checkable","checkbox","tracker","createTracker","move","defaultHandlers","current","replace","$0"],"mappings":"kHAoBO,SAASA,IACd,MAAO,CACLC,KAAM,CACJC,0BAA2BC,EAC3BC,4BAA6BD,EAC7BE,UAAWC,GAGjB,CASO,SAASC,IACd,MAAO,CACLC,OAAQ,CAAC,CAACC,SAAS,EAAMC,UAAW,IAAKC,MAAO,UAChDC,SAAU,CAACC,SAAUC,GAEzB,CAMA,SAASX,EAAUY,GAEjB,MAAMC,EAAOC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5CC,EAAqB,aAAdJ,EAAKK,MACZL,EAAKM,QAAyB,8BAAfP,EAAMM,IACvB,CAMA,SAASf,EAA8BS,GACrC,MAAMQ,EAASN,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAE9C,GACEI,GACgB,aAAhBA,EAAOF,MACmB,kBAAnBE,EAAOD,QACd,CACA,MAAMN,EAAOC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5CC,EAAqB,cAAdJ,EAAKK,MACZ,MAAMG,EAAOR,EAAKS,SAAS,GAE3B,GAAID,GAAsB,SAAdA,EAAKH,KAAiB,CAChC,MAAMK,EAAWH,EAAOE,SACxB,IAEIE,EAFAC,GAAQ,EAIZ,OAASA,EAAQF,EAASP,QAAQ,CAChC,MAAMU,EAAUH,EAASE,GACzB,GAAqB,cAAjBC,EAAQR,KAAsB,CAChCM,EAAkBE,EAClB,KACV,CACA,CAEUF,IAAoBX,IAEtBQ,EAAKM,MAAQN,EAAKM,MAAMC,MAAM,GAEJ,IAAtBP,EAAKM,MAAMX,OACbH,EAAKS,SAASO,QAEdhB,EAAKiB,UACLT,EAAKS,UACiC,iBAA/BT,EAAKS,SAASC,MAAMC,SAE3BX,EAAKS,SAASC,MAAME,SACpBZ,EAAKS,SAASC,MAAMC,SACpBnB,EAAKiB,SAASC,MAAQG,OAAOC,OAAO,GAAId,EAAKS,SAASC,QAGhE,CACA,CAEEjB,KAAKhB,KAAKc,EACZ,CAMA,SAASD,EAAyBE,EAAMO,EAAQgB,EAAOC,GACrD,MAAMhB,EAAOR,EAAKS,SAAS,GACrBgB,EACoB,kBAAjBzB,EAAKM,SAAyBE,GAAsB,cAAdA,EAAKH,KAC9CqB,EAAW,KAAO1B,EAAKM,QAAU,IAAM,KAAO,KAC9CqB,EAAUJ,EAAMK,cAAcJ,GAEhCC,GACFE,EAAQE,KAAKH,GAGf,IAAIZ,EAAQgB,EAAgBjC,SAASG,EAAMO,EAAQgB,EAAO,IACrDC,KACAG,EAAQI,YAOb,OAJIN,IACFX,EAAQA,EAAMkB,QAAQ,mCASxB,SAAeC,GACb,OAAOA,EAAKP,CAChB,KARSZ,CAST","x_google_ignoreList":[0]}