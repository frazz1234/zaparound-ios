{"version":3,"file":"vendor--mdast-util-from-markdown.DI8nvaYJ.js","sources":["../../../../node_modules/mdast-util-from-markdown/lib/index.js"],"sourcesContent":["/**\n * @import {\n *   Break,\n *   Blockquote,\n *   Code,\n *   Definition,\n *   Emphasis,\n *   Heading,\n *   Html,\n *   Image,\n *   InlineCode,\n *   Link,\n *   ListItem,\n *   List,\n *   Nodes,\n *   Paragraph,\n *   PhrasingContent,\n *   ReferenceType,\n *   Root,\n *   Strong,\n *   Text,\n *   ThematicBreak\n * } from 'mdast'\n * @import {\n *   Encoding,\n *   Event,\n *   Token,\n *   Value\n * } from 'micromark-util-types'\n * @import {Point} from 'unist'\n * @import {\n *   CompileContext,\n *   CompileData,\n *   Config,\n *   Extension,\n *   Handle,\n *   OnEnterError,\n *   Options\n * } from './types.js'\n */\n\nimport { toString } from 'mdast-util-to-string';\nimport { parse, postprocess, preprocess } from 'micromark';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nimport { decodeString } from 'micromark-util-decode-string';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { stringifyPosition } from 'unist-util-stringify-position';\nconst own = {}.hasOwnProperty;\n\n/**\n * Turn markdown into a syntax tree.\n *\n * @overload\n * @param {Value} value\n * @param {Encoding | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @overload\n * @param {Value} value\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @param {Value} value\n *   Markdown to parse.\n * @param {Encoding | Options | null | undefined} [encoding]\n *   Character encoding for when `value` is `Buffer`.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Root}\n *   mdast tree.\n */\nexport function fromMarkdown(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding;\n    encoding = undefined;\n  }\n  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));\n}\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      characterReference: onexitcharacterreference,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  };\n  configure(config, (options || {}).mdastExtensions || []);\n\n  /** @type {CompileData} */\n  const data = {};\n  return compile;\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    };\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      data\n    };\n    /** @type {Array<number>} */\n    const listStack = [];\n    let index = -1;\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (events[index][1].type === \"listOrdered\" || events[index][1].type === \"listUnordered\") {\n        if (events[index][0] === 'enter') {\n          listStack.push(index);\n        } else {\n          const tail = listStack.pop();\n          index = prepareList(events, tail, index);\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      const handler = config[events[index][0]];\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(Object.assign({\n          sliceSerialize: events[index][2].sliceSerialize\n        }, context), events[index][1]);\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1];\n      const handler = tail[1] || defaultOnError;\n      handler.call(context, undefined, tail[0]);\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(events.length > 0 ? events[0][1].start : {\n        line: 1,\n        column: 1,\n        offset: 0\n      }),\n      end: point(events.length > 0 ? events[events.length - 2][1].end : {\n        line: 1,\n        column: 1,\n        offset: 0\n      })\n    };\n\n    // Call transforms.\n    index = -1;\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree;\n    }\n    return tree;\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1;\n    let containerBalance = -1;\n    let listSpread = false;\n    /** @type {Token | undefined} */\n    let listItem;\n    /** @type {number | undefined} */\n    let lineIndex;\n    /** @type {number | undefined} */\n    let firstBlankLineIndex;\n    /** @type {boolean | undefined} */\n    let atMarker;\n    while (++index <= length) {\n      const event = events[index];\n      switch (event[1].type) {\n        case \"listUnordered\":\n        case \"listOrdered\":\n        case \"blockQuote\":\n          {\n            if (event[0] === 'enter') {\n              containerBalance++;\n            } else {\n              containerBalance--;\n            }\n            atMarker = undefined;\n            break;\n          }\n        case \"lineEndingBlank\":\n          {\n            if (event[0] === 'enter') {\n              if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n                firstBlankLineIndex = index;\n              }\n              atMarker = undefined;\n            }\n            break;\n          }\n        case \"linePrefix\":\n        case \"listItemValue\":\n        case \"listItemMarker\":\n        case \"listItemPrefix\":\n        case \"listItemPrefixWhitespace\":\n          {\n            // Empty.\n\n            break;\n          }\n        default:\n          {\n            atMarker = undefined;\n          }\n      }\n      if (!containerBalance && event[0] === 'enter' && event[1].type === \"listItemPrefix\" || containerBalance === -1 && event[0] === 'exit' && (event[1].type === \"listUnordered\" || event[1].type === \"listOrdered\")) {\n        if (listItem) {\n          let tailIndex = index;\n          lineIndex = undefined;\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex];\n            if (tailEvent[1].type === \"lineEnding\" || tailEvent[1].type === \"lineEndingBlank\") {\n              if (tailEvent[0] === 'exit') continue;\n              if (lineIndex) {\n                events[lineIndex][1].type = \"lineEndingBlank\";\n                listSpread = true;\n              }\n              tailEvent[1].type = \"lineEnding\";\n              lineIndex = tailIndex;\n            } else if (tailEvent[1].type === \"linePrefix\" || tailEvent[1].type === \"blockQuotePrefix\" || tailEvent[1].type === \"blockQuotePrefixWhitespace\" || tailEvent[1].type === \"blockQuoteMarker\" || tailEvent[1].type === \"listItemIndent\") {\n              // Empty\n            } else {\n              break;\n            }\n          }\n          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n            listItem._spread = true;\n          }\n\n          // Fix position.\n          listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);\n          index++;\n          length++;\n        }\n\n        // Create a new list item.\n        if (event[1].type === \"listItemPrefix\") {\n          /** @type {Token} */\n          const item = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: we’ll add `end` in a second.\n            end: undefined\n          };\n          listItem = item;\n          events.splice(index, 0, ['enter', item, event[2]]);\n          index++;\n          length++;\n          firstBlankLineIndex = undefined;\n          atMarker = true;\n        }\n      }\n    }\n    events[start][1]._spread = listSpread;\n    return length;\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Nodes} create\n   *   Create a node.\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open;\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function open(token) {\n      enter.call(this, create(token), token);\n      if (and) and.call(this, token);\n    }\n  }\n\n  /**\n   * @type {CompileContext['buffer']}\n   */\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    });\n  }\n\n  /**\n   * @type {CompileContext['enter']}\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1];\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children;\n    siblings.push(node);\n    this.stack.push(node);\n    this.tokenStack.push([token, errorHandler || undefined]);\n    node.position = {\n      start: point(token.start),\n      // @ts-expect-error: `end` will be patched later.\n      end: undefined\n    };\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close;\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function close(token) {\n      if (and) and.call(this, token);\n      exit.call(this, token);\n    }\n  }\n\n  /**\n   * @type {CompileContext['exit']}\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop();\n    const open = this.tokenStack.pop();\n    if (!open) {\n      throw new Error('Cannot close `' + token.type + '` (' + stringifyPosition({\n        start: token.start,\n        end: token.end\n      }) + '): it’s not open');\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0]);\n      } else {\n        const handler = open[1] || defaultOnError;\n        handler.call(this, token, open[0]);\n      }\n    }\n    node.position.end = point(token.end);\n  }\n\n  /**\n   * @type {CompileContext['resume']}\n   */\n  function resume() {\n    return toString(this.stack.pop());\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    this.data.expectingFirstListItemValue = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (this.data.expectingFirstListItemValue) {\n      const ancestor = this.stack[this.stack.length - 2];\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);\n      this.data.expectingFirstListItemValue = undefined;\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.lang = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (this.data.flowCodeInside) return;\n    this.buffer();\n    this.data.flowCodeInside = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    this.data.flowCodeInside = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '');\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length;\n      node.depth = depth;\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    this.data.setextHeadingSlurpLineEnding = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    node.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    this.data.setextHeadingSlurpLineEnding = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1];\n    /** @type {Array<Nodes>} */\n    const siblings = node.children;\n    let tail = siblings[siblings.length - 1];\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text();\n      tail.position = {\n        start: point(token.start),\n        // @ts-expect-error: we’ll add `end` later.\n        end: undefined\n      };\n      siblings.push(tail);\n    }\n    this.stack.push(tail);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop();\n    tail.value += this.sliceSerialize(token);\n    tail.position.end = point(token.end);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1];\n    // If we’re at a hard break, include the line ending in there.\n    if (this.data.atHardBreak) {\n      const tail = context.children[context.children.length - 1];\n      tail.position.end = point(token.end);\n      this.data.atHardBreak = undefined;\n      return;\n    }\n    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {\n      onenterdata.call(this, token);\n      onexitdata.call(this, token);\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    this.data.atHardBreak = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1];\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut';\n      node.type += 'Reference';\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType;\n      // @ts-expect-error: mutate.\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier;\n      // @ts-expect-error: mutate.\n      delete node.label;\n    }\n    this.data.referenceType = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1];\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut';\n      node.type += 'Reference';\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType;\n      // @ts-expect-error: mutate.\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier;\n      // @ts-expect-error: mutate.\n      delete node.label;\n    }\n    this.data.referenceType = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token);\n    const ancestor = this.stack[this.stack.length - 2];\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string);\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase();\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1];\n    const value = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    // Assume a reference.\n    this.data.inReference = true;\n    if (node.type === 'link') {\n      /** @type {Array<PhrasingContent>} */\n      const children = fragment.children;\n      node.children = children;\n    } else {\n      node.alt = value;\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    this.data.inReference = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    this.data.referenceType = 'collapsed';\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label;\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n    this.data.referenceType = 'full';\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    this.data.characterReferenceType = token.type;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token);\n    const type = this.data.characterReferenceType;\n    /** @type {string} */\n    let value;\n    if (type) {\n      value = decodeNumericCharacterReference(data, type === \"characterReferenceMarkerNumeric\" ? 10 : 16);\n      this.data.characterReferenceType = undefined;\n    } else {\n      const result = decodeNamedCharacterReference(data);\n      value = result;\n    }\n    const tail = this.stack[this.stack.length - 1];\n    tail.value += value;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreference(token) {\n    const tail = this.stack.pop();\n    tail.position.end = point(token.end);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    node.url = this.sliceSerialize(token);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    node.url = 'mailto:' + this.sliceSerialize(token);\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    };\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    };\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    };\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    };\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    };\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    return {\n      type: 'heading',\n      // @ts-expect-error `depth` will be set later.\n      depth: 0,\n      children: []\n    };\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {\n      type: 'break'\n    };\n  }\n\n  /** @returns {Html} */\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    };\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    };\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    };\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    };\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    };\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    };\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    };\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    };\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    };\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  };\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Array<Extension> | Extension>} extensions\n * @returns {undefined}\n */\nfunction configure(combined, extensions) {\n  let index = -1;\n  while (++index < extensions.length) {\n    const value = extensions[index];\n    if (Array.isArray(value)) {\n      configure(combined, value);\n    } else {\n      extension(combined, value);\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {undefined}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key;\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'canContainEols':\n          {\n            const right = extension[key];\n            if (right) {\n              combined[key].push(...right);\n            }\n            break;\n          }\n        case 'transforms':\n          {\n            const right = extension[key];\n            if (right) {\n              combined[key].push(...right);\n            }\n            break;\n          }\n        case 'enter':\n        case 'exit':\n          {\n            const right = extension[key];\n            if (right) {\n              Object.assign(combined[key], right);\n            }\n            break;\n          }\n        // No default\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error('Cannot close `' + left.type + '` (' + stringifyPosition({\n      start: left.start,\n      end: left.end\n    }) + '): a different token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is open');\n  } else {\n    throw new Error('Cannot close document, a token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is still open');\n  }\n}"],"names":["own","hasOwnProperty","fromMarkdown","value","encoding","options","undefined","config","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","data","codeFlowValue","definition","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","html","htmlFlowData","htmlText","htmlTextData","image","label","listItem","listItemValue","onenterlistitemvalue","listOrdered","list","onenterlistordered","listUnordered","paragraph","reference","onenterreference","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","onexitatxheadingsequence","onexitautolinkemail","onexitautolinkprotocol","characterEscapeValue","onexitdata","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","onexitcharacterreferencevalue","onexitcharacterreference","onexitcodefenced","codeFencedFence","onexitcodefencedfence","onexitcodefencedfenceinfo","onexitcodefencedfencemeta","onexitcodeindented","onexitcodetext","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexithardbreak","onexithtmlflow","onexithtmltext","onexitimage","onexitlabel","labelText","onexitlabeltext","lineEnding","onexitlineending","onexitlink","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","resource","onexitresource","onexitsetextheading","setextHeadingLineSequence","onexitsetextheadinglinesequence","setextHeadingText","onexitsetextheadingtext","configure","mdastExtensions","compile","events","tree","type","children","context","stack","tokenStack","resume","listStack","index","length","push","prepareList","pop","handler","call","Object","assign","sliceSerialize","tail","defaultOnError","position","start","point","line","column","offset","end","lineIndex","firstBlankLineIndex","atMarker","containerBalance","listSpread","event","tailIndex","tailEvent","_spread","splice","item","create","and","open","token","this","node","errorHandler","close","onExitError","Error","stringifyPosition","toString","expectingFirstListItemValue","Number","parseInt","lang","meta","flowCodeInside","replace","identifier","normalizeIdentifier","toLowerCase","title","url","depth","setextHeadingSlurpLineEnding","codePointAt","siblings","text","atHardBreak","includes","inReference","referenceType","string","ancestor","decodeString","fragment","alt","characterReferenceType","decodeNumericCharacterReference","decodeNamedCharacterReference","ordered","spread","checked","compiler","postprocess","parse","document","write","preprocess","d","combined","extensions","Array","isArray","extension","key","right","left"],"mappings":"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","x_google_ignoreList":[0]}