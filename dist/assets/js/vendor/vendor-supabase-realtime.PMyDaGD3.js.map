{"version":3,"mappings":"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","names":["DEFAULT_HEADERS","SOCKET_STATES","CHANNEL_STATES","CHANNEL_EVENTS","TRANSPORTS","CONNECTION_STATE","PostgresTypes","Serializer","constructor","this","HEADER_LENGTH","decode","rawPayload","callback","ArrayBuffer","_binaryDecode","JSON","parse","buffer","view","DataView","decoder","TextDecoder","_decodeBroadcast","topicSize","getUint8","eventSize","offset","topic","slice","event","ref","payload","byteLength","Timer","timerCalc","timer","undefined","tries","reset","clearTimeout","scheduleTimeout","setTimeout","convertChangeData","columns","record","options","_a","skipTypes","Object","keys","reduce","acc","rec_key","convertColumn","columnName","column","find","x","name","colType","type","value","includes","convertCell","noop","charAt","dataType","length","toArray","bool","toBoolean","float4","float8","int2","int4","int8","numeric","oid","toNumber","json","jsonb","toJson","timestamp","toTimestampString","abstime","date","daterange","int4range","int8range","money","reltime","text","time","timestamptz","timetz","tsrange","tstzrange","parsedValue","parseFloat","Number","isNaN","error","lastIdx","closeBrace","arr","valTrim","_","split","map","val","replace","httpEndpointURL","socketUrl","url","Push","channel","timeout","sent","timeoutTimer","receivedResp","recHooks","refEvent","resend","_cancelRefEvent","send","_hasReceived","startTimeout","socket","push","join_ref","_joinRef","updatePayload","assign","receive","status","response","_makeRef","_replyEventName","_on","_cancelTimeout","_matchReceive","trigger","_trigger","destroy","_off","filter","h","forEach","REALTIME_PRESENCE_LISTEN_EVENTS","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","RealtimePresence","opts","state","pendingDiffs","joinRef","caller","onJoin","onLeave","onSync","events","diff","newState","syncState","syncDiff","inPendingSyncState","key","currentPresences","newPresences","leftPresences","currentState","cloneDeep","transformedState","transformState","joins","leaves","presences","newPresenceRefs","m","presence_ref","curPresenceRefs","joinedPresences","indexOf","joinedPresenceRefs","curPresences","unshift","presenceRefsToRemove","obj","func","getOwnPropertyNames","metas","presence","stringify","RealtimeChannel","params","config","bindings","closed","joinedOnce","pushBuffer","subTopic","broadcast","ack","self","private","joinPush","join","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","joined","pushEvent","_onClose","log","_remove","_onError","reason","_isLeaving","_isClosed","errored","_isJoining","reply","broadcastEndpointURL","endPoint","subscribe","_b","isConnected","connect","isPrivate","e","CHANNEL_ERROR","CLOSED","accessTokenPayload","postgres_changes","r","accessTokenValue","access_token","updateJoinPayload","_rejoin","async","setAuth","clientPostgresBindings","bindingsLen","newPostgresBindings","i","clientPostgresBinding","schema","table","serverPostgresFilter","unsubscribe","Error","id","SUBSCRIBED","values","TIMED_OUT","presenceState","track","untrack","on","args","_canPush","Promise","resolve","_c","_push","endpoint_payload","method","headers","Authorization","apikey","apiKey","body","messages","_fetchWithTimeout","cancel","ok","leaving","onClose","close","leavePush","leave","controller","AbortController","abort","fetch","signal","_onMessage","_event","_ref","_isMember","typeLower","toLocaleLowerCase","handledPayload","bind","_d","_e","_f","bindId","bindEvent","ids","data","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","_isJoined","joining","binding","isEqual","obj1","obj2","k","_leaveOpenTopic","records","Transformers.convertChangeData","old_record","NATIVE_WEBSOCKET_AVAILABLE","WebSocket","RealtimeClient","channels","httpEndpoint","heartbeatIntervalMs","heartbeatTimer","pendingHeartbeatRef","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","message","accessToken","_resolveFetch","customFetch","_fetch","__vitePreload","default","import","then","n","b","__VITE_PRELOAD__","websocket","transport","encode","reconnectTimer","disconnect","worker","window","Worker","workerUrl","endpointURL","setupConnection","WSWebSocketDummy","WS","_appendParams","vsn","code","onclose","clearInterval","getChannels","removeChannel","removeAllChannels","values_1","all","kind","msg","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","chan","result","token","tokenToSend","parsed","atob","_error","exp","Math","floor","Date","now","reject","sendHeartbeat","flushSendBuffer","newRef","toString","dupChannel","c","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","_onConnMessage","_onConnClose","rawMessage","objectUrl","_workerObjectUrl","workerRef","terminate","postMessage","interval","setInterval","_triggerChanError","prefix","match","URLSearchParams","result_url","blob","Blob","URL","createObjectURL","address","_protocols"],"ignoreList":[0,1,2,3,4,5,6,7,8],"sources":["../../../../node_modules/@supabase/realtime-js/dist/module/lib/version.js","../../../../node_modules/@supabase/realtime-js/dist/module/lib/constants.js","../../../../node_modules/@supabase/realtime-js/dist/module/lib/transformers.js","../../../../node_modules/@supabase/realtime-js/dist/module/lib/serializer.js","../../../../node_modules/@supabase/realtime-js/dist/module/lib/timer.js","../../../../node_modules/@supabase/realtime-js/dist/module/lib/push.js","../../../../node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js","../../../../node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js","../../../../node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js"],"sourcesContent":["export const version = '2.11.2';\n//# sourceMappingURL=version.js.map","import { version } from './version';\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `realtime-js/${version}` };\nexport const VSN = '1.0.0';\nexport const DEFAULT_TIMEOUT = 10000;\nexport const WS_CLOSE_NORMAL = 1000;\nexport var SOCKET_STATES;\n(function (SOCKET_STATES) {\n    SOCKET_STATES[SOCKET_STATES[\"connecting\"] = 0] = \"connecting\";\n    SOCKET_STATES[SOCKET_STATES[\"open\"] = 1] = \"open\";\n    SOCKET_STATES[SOCKET_STATES[\"closing\"] = 2] = \"closing\";\n    SOCKET_STATES[SOCKET_STATES[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (SOCKET_STATES = {}));\nexport var CHANNEL_STATES;\n(function (CHANNEL_STATES) {\n    CHANNEL_STATES[\"closed\"] = \"closed\";\n    CHANNEL_STATES[\"errored\"] = \"errored\";\n    CHANNEL_STATES[\"joined\"] = \"joined\";\n    CHANNEL_STATES[\"joining\"] = \"joining\";\n    CHANNEL_STATES[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (CHANNEL_STATES = {}));\nexport var CHANNEL_EVENTS;\n(function (CHANNEL_EVENTS) {\n    CHANNEL_EVENTS[\"close\"] = \"phx_close\";\n    CHANNEL_EVENTS[\"error\"] = \"phx_error\";\n    CHANNEL_EVENTS[\"join\"] = \"phx_join\";\n    CHANNEL_EVENTS[\"reply\"] = \"phx_reply\";\n    CHANNEL_EVENTS[\"leave\"] = \"phx_leave\";\n    CHANNEL_EVENTS[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));\nexport var TRANSPORTS;\n(function (TRANSPORTS) {\n    TRANSPORTS[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (TRANSPORTS = {}));\nexport var CONNECTION_STATE;\n(function (CONNECTION_STATE) {\n    CONNECTION_STATE[\"Connecting\"] = \"connecting\";\n    CONNECTION_STATE[\"Open\"] = \"open\";\n    CONNECTION_STATE[\"Closing\"] = \"closing\";\n    CONNECTION_STATE[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (CONNECTION_STATE = {}));\n//# sourceMappingURL=constants.js.map","/**\n * Helpers to convert the change Payload into native JS types.\n */\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nexport var PostgresTypes;\n(function (PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nexport const convertChangeData = (columns, record, options = {}) => {\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    return Object.keys(record).reduce((acc, rec_key) => {\n        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nexport const convertColumn = (columnName, columns, record, skipTypes) => {\n    const column = columns.find((x) => x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return convertCell(colType, value);\n    }\n    return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nexport const convertCell = (type, value) => {\n    // if data type is an array\n    if (type.charAt(0) === '_') {\n        const dataType = type.slice(1, type.length);\n        return toArray(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch (type) {\n        case PostgresTypes.bool:\n            return toBoolean(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return toNumber(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return toJson(value);\n        case PostgresTypes.timestamp:\n            return toTimestampString(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n        case PostgresTypes.date: // To allow users to cast it based on Timezone\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n        case PostgresTypes.text:\n        case PostgresTypes.time: // To allow users to cast it based on Timezone\n        case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n        case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nconst noop = (value) => {\n    return value;\n};\nexport const toBoolean = (value) => {\n    switch (value) {\n        case 't':\n            return true;\n        case 'f':\n            return false;\n        default:\n            return value;\n    }\n};\nexport const toNumber = (value) => {\n    if (typeof value === 'string') {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nexport const toJson = (value) => {\n    if (typeof value === 'string') {\n        try {\n            return JSON.parse(value);\n        }\n        catch (error) {\n            console.log(`JSON parse error: ${error}`);\n            return value;\n        }\n    }\n    return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nexport const toArray = (value, type) => {\n    if (typeof value !== 'string') {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === '{' && closeBrace === '}') {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse('[' + valTrim + ']');\n        }\n        catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(',') : [];\n        }\n        return arr.map((val) => convertCell(type, val));\n    }\n    return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nexport const toTimestampString = (value) => {\n    if (typeof value === 'string') {\n        return value.replace(' ', 'T');\n    }\n    return value;\n};\nexport const httpEndpointURL = (socketUrl) => {\n    let url = socketUrl;\n    url = url.replace(/^ws/i, 'http');\n    url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '');\n    return url.replace(/\\/+$/, '');\n};\n//# sourceMappingURL=transformers.js.map","// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\nexport default class Serializer {\n    constructor() {\n        this.HEADER_LENGTH = 1;\n    }\n    decode(rawPayload, callback) {\n        if (rawPayload.constructor === ArrayBuffer) {\n            return callback(this._binaryDecode(rawPayload));\n        }\n        if (typeof rawPayload === 'string') {\n            return callback(JSON.parse(rawPayload));\n        }\n        return callback({});\n    }\n    _binaryDecode(buffer) {\n        const view = new DataView(buffer);\n        const decoder = new TextDecoder();\n        return this._decodeBroadcast(buffer, view, decoder);\n    }\n    _decodeBroadcast(buffer, view, decoder) {\n        const topicSize = view.getUint8(1);\n        const eventSize = view.getUint8(2);\n        let offset = this.HEADER_LENGTH + 2;\n        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n        offset = offset + topicSize;\n        const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n        offset = offset + eventSize;\n        const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));\n        return { ref: null, topic: topic, event: event, payload: data };\n    }\n}\n//# sourceMappingURL=serializer.js.map","/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */\nexport default class Timer {\n    constructor(callback, timerCalc) {\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(() => {\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n}\n//# sourceMappingURL=timer.js.map","import { DEFAULT_TIMEOUT } from '../lib/constants';\nexport default class Push {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */\n    constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = '';\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = '';\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived('timeout')) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel._joinRef(),\n        });\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({ status, callback });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket._makeRef();\n        this.refEvent = this.channel._replyEventName(this.ref);\n        const callback = (payload) => {\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel._on(this.refEvent, {}, callback);\n        this.timeoutTimer = setTimeout(() => {\n            this.trigger('timeout', {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent)\n            this.channel._trigger(this.refEvent, { status, response });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel._off(this.refEvent, {});\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status, response, }) {\n        this.recHooks\n            .filter((h) => h.status === status)\n            .forEach((h) => h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n}\n//# sourceMappingURL=push.js.map","/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/\nexport var REALTIME_PRESENCE_LISTEN_EVENTS;\n(function (REALTIME_PRESENCE_LISTEN_EVENTS) {\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"SYNC\"] = \"sync\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"JOIN\"] = \"join\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nexport default class RealtimePresence {\n    /**\n     * Initializes the Presence.\n     *\n     * @param channel - The RealtimeChannel\n     * @param opts - The options,\n     *        for example `{events: {state: 'state', diff: 'diff'}}`\n     */\n    constructor(channel, opts) {\n        this.channel = channel;\n        this.state = {};\n        this.pendingDiffs = [];\n        this.joinRef = null;\n        this.caller = {\n            onJoin: () => { },\n            onLeave: () => { },\n            onSync: () => { },\n        };\n        const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n            state: 'presence_state',\n            diff: 'presence_diff',\n        };\n        this.channel._on(events.state, {}, (newState) => {\n            const { onJoin, onLeave, onSync } = this.caller;\n            this.joinRef = this.channel._joinRef();\n            this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n            this.pendingDiffs.forEach((diff) => {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n            });\n            this.pendingDiffs = [];\n            onSync();\n        });\n        this.channel._on(events.diff, {}, (diff) => {\n            const { onJoin, onLeave, onSync } = this.caller;\n            if (this.inPendingSyncState()) {\n                this.pendingDiffs.push(diff);\n            }\n            else {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n                onSync();\n            }\n        });\n        this.onJoin((key, currentPresences, newPresences) => {\n            this.channel._trigger('presence', {\n                event: 'join',\n                key,\n                currentPresences,\n                newPresences,\n            });\n        });\n        this.onLeave((key, currentPresences, leftPresences) => {\n            this.channel._trigger('presence', {\n                event: 'leave',\n                key,\n                currentPresences,\n                leftPresences,\n            });\n        });\n        this.onSync(() => {\n            this.channel._trigger('presence', { event: 'sync' });\n        });\n    }\n    /**\n     * Used to sync the list of presences on the server with the\n     * client's state.\n     *\n     * An optional `onJoin` and `onLeave` callback can be provided to\n     * react to changes in the client's local presences across\n     * disconnects and reconnects with the server.\n     *\n     * @internal\n     */\n    static syncState(currentState, newState, onJoin, onLeave) {\n        const state = this.cloneDeep(currentState);\n        const transformedState = this.transformState(newState);\n        const joins = {};\n        const leaves = {};\n        this.map(state, (key, presences) => {\n            if (!transformedState[key]) {\n                leaves[key] = presences;\n            }\n        });\n        this.map(transformedState, (key, newPresences) => {\n            const currentPresences = state[key];\n            if (currentPresences) {\n                const newPresenceRefs = newPresences.map((m) => m.presence_ref);\n                const curPresenceRefs = currentPresences.map((m) => m.presence_ref);\n                const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);\n                const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);\n                if (joinedPresences.length > 0) {\n                    joins[key] = joinedPresences;\n                }\n                if (leftPresences.length > 0) {\n                    leaves[key] = leftPresences;\n                }\n            }\n            else {\n                joins[key] = newPresences;\n            }\n        });\n        return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n    }\n    /**\n     * Used to sync a diff of presence join and leave events from the\n     * server, as they happen.\n     *\n     * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n     * `onLeave` callbacks to react to a user joining or leaving from a\n     * device.\n     *\n     * @internal\n     */\n    static syncDiff(state, diff, onJoin, onLeave) {\n        const { joins, leaves } = {\n            joins: this.transformState(diff.joins),\n            leaves: this.transformState(diff.leaves),\n        };\n        if (!onJoin) {\n            onJoin = () => { };\n        }\n        if (!onLeave) {\n            onLeave = () => { };\n        }\n        this.map(joins, (key, newPresences) => {\n            var _a;\n            const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n            state[key] = this.cloneDeep(newPresences);\n            if (currentPresences.length > 0) {\n                const joinedPresenceRefs = state[key].map((m) => m.presence_ref);\n                const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n                state[key].unshift(...curPresences);\n            }\n            onJoin(key, currentPresences, newPresences);\n        });\n        this.map(leaves, (key, leftPresences) => {\n            let currentPresences = state[key];\n            if (!currentPresences)\n                return;\n            const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);\n            currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n            state[key] = currentPresences;\n            onLeave(key, currentPresences, leftPresences);\n            if (currentPresences.length === 0)\n                delete state[key];\n        });\n        return state;\n    }\n    /** @internal */\n    static map(obj, func) {\n        return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n    }\n    /**\n     * Remove 'metas' key\n     * Change 'phx_ref' to 'presence_ref'\n     * Remove 'phx_ref' and 'phx_ref_prev'\n     *\n     * @example\n     * // returns {\n     *  abc123: [\n     *    { presence_ref: '2', user_id: 1 },\n     *    { presence_ref: '3', user_id: 2 }\n     *  ]\n     * }\n     * RealtimePresence.transformState({\n     *  abc123: {\n     *    metas: [\n     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n     *      { phx_ref: '3', user_id: 2 }\n     *    ]\n     *  }\n     * })\n     *\n     * @internal\n     */\n    static transformState(state) {\n        state = this.cloneDeep(state);\n        return Object.getOwnPropertyNames(state).reduce((newState, key) => {\n            const presences = state[key];\n            if ('metas' in presences) {\n                newState[key] = presences.metas.map((presence) => {\n                    presence['presence_ref'] = presence['phx_ref'];\n                    delete presence['phx_ref'];\n                    delete presence['phx_ref_prev'];\n                    return presence;\n                });\n            }\n            else {\n                newState[key] = presences;\n            }\n            return newState;\n        }, {});\n    }\n    /** @internal */\n    static cloneDeep(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /** @internal */\n    onJoin(callback) {\n        this.caller.onJoin = callback;\n    }\n    /** @internal */\n    onLeave(callback) {\n        this.caller.onLeave = callback;\n    }\n    /** @internal */\n    onSync(callback) {\n        this.caller.onSync = callback;\n    }\n    /** @internal */\n    inPendingSyncState() {\n        return !this.joinRef || this.joinRef !== this.channel._joinRef();\n    }\n}\n//# sourceMappingURL=RealtimePresence.js.map","import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nimport { httpEndpointURL } from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n    constructor(\n    /** Topic name can be any string. */\n    topic, params = { config: {} }, socket) {\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, '');\n        this.params.config = Object.assign({\n            broadcast: { ack: false, self: false },\n            presence: { key: '' },\n            private: false,\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n            this.state = CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new RealtimePresence(this);\n        this.broadcastEndpointURL =\n            httpEndpointURL(this.socket.endPoint) + '/api/broadcast';\n        this.private = this.params.config.private || false;\n    }\n    /** Subscribe registers your client with the server */\n    subscribe(callback, timeout = this.timeout) {\n        var _a, _b;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.joinedOnce) {\n            throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n        }\n        else {\n            const { config: { broadcast, presence, private: isPrivate }, } = this.params;\n            this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n            this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence,\n                postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [],\n                private: isPrivate,\n            };\n            if (this.socket.accessTokenValue) {\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\n            }\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush\n                .receive('ok', async ({ postgres_changes }) => {\n                var _a;\n                this.socket.setAuth();\n                if (postgres_changes === undefined) {\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n                else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for (let i = 0; i < bindingsLen; i++) {\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\n                        if (serverPostgresFilter &&\n                            serverPostgresFilter.event === event &&\n                            serverPostgresFilter.schema === schema &&\n                            serverPostgresFilter.table === table &&\n                            serverPostgresFilter.filter === filter) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\n                        }\n                        else {\n                            this.unsubscribe();\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n            })\n                .receive('error', (error) => {\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n                return;\n            })\n                .receive('timeout', () => {\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n                return;\n            });\n        }\n        return this;\n    }\n    presenceState() {\n        return this.presence.state;\n    }\n    async track(payload, opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'track',\n            payload,\n        }, opts.timeout || this.timeout);\n    }\n    async untrack(opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'untrack',\n        }, opts);\n    }\n    on(type, filter, callback) {\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */\n    async send(args, opts = {}) {\n        var _a, _b;\n        if (!this._canPush() && args.type === 'broadcast') {\n            const { event, payload: endpoint_payload } = args;\n            const authorization = this.socket.accessTokenValue\n                ? `Bearer ${this.socket.accessTokenValue}`\n                : '';\n            const options = {\n                method: 'POST',\n                headers: {\n                    Authorization: authorization,\n                    apikey: this.socket.apiKey ? this.socket.apiKey : '',\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            topic: this.subTopic,\n                            event,\n                            payload: endpoint_payload,\n                            private: this.private,\n                        },\n                    ],\n                }),\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n                return response.ok ? 'ok' : 'error';\n            }\n            catch (error) {\n                if (error.name === 'AbortError') {\n                    return 'timed out';\n                }\n                else {\n                    return 'error';\n                }\n            }\n        }\n        else {\n            return new Promise((resolve) => {\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve('ok');\n                }\n                push.receive('ok', () => resolve('ok'));\n                push.receive('error', () => resolve('error'));\n                push.receive('timeout', () => resolve('timed out'));\n            });\n        }\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = CHANNEL_STATES.leaving;\n        const onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n        };\n        this.rejoinTimer.reset();\n        // Destroy joinPush to avoid connection timeouts during unscription phase\n        this.joinPush.destroy();\n        return new Promise((resolve) => {\n            const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush\n                .receive('ok', () => {\n                onClose();\n                resolve('ok');\n            })\n                .receive('timeout', () => {\n                onClose();\n                resolve('timed out');\n            })\n                .receive('error', () => {\n                resolve('error');\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger('ok', {});\n            }\n        });\n    }\n    /** @internal */\n    async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(() => controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */\n    _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new Push(this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        }\n        else {\n            pushEvent.startTimeout();\n            this.pushBuffer.push(pushEvent);\n        }\n        return pushEvent;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */\n    _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */\n    _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */\n    _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */\n    _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = CHANNEL_EVENTS;\n        const events = [close, error, leave, join];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\n                var _a, _b, _c;\n                return (((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' ||\n                    ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower);\n            }).map((bind) => bind.callback(handledPayload, ref));\n        }\n        else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\n                var _a, _b, _c, _d, _e, _f;\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n                    if ('id' in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return (bindId &&\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\n                            (bindEvent === '*' ||\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) ===\n                                    ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\n                    }\n                    else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return (bindEvent === '*' ||\n                            bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase()));\n                    }\n                }\n                else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind) => {\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors,\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */\n    _isClosed() {\n        return this.state === CHANNEL_STATES.closed;\n    }\n    /** @internal */\n    _isJoined() {\n        return this.state === CHANNEL_STATES.joined;\n    }\n    /** @internal */\n    _isJoining() {\n        return this.state === CHANNEL_STATES.joining;\n    }\n    /** @internal */\n    _isLeaving() {\n        return this.state === CHANNEL_STATES.leaving;\n    }\n    /** @internal */\n    _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */\n    _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback,\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        }\n        else {\n            this.bindings[typeLower] = [binding];\n        }\n        return this;\n    }\n    /** @internal */\n    _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n            var _a;\n            return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\n                RealtimeChannel.isEqual(bind.filter, filter));\n        });\n        return this;\n    }\n    /** @internal */\n    static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (const k in obj1) {\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** @internal */\n    _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */\n    _onClose(callback) {\n        this._on(CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */\n    _onError(callback) {\n        this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */\n    _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */\n    _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */\n    _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {},\n        };\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n}\n//# sourceMappingURL=RealtimeChannel.js.map","import { CHANNEL_EVENTS, CONNECTION_STATE, DEFAULT_HEADERS, DEFAULT_TIMEOUT, SOCKET_STATES, TRANSPORTS, VSN, WS_CLOSE_NORMAL, } from './lib/constants';\nimport Serializer from './lib/serializer';\nimport Timer from './lib/timer';\nimport { httpEndpointURL } from './lib/transformers';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => { };\nconst NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== 'undefined';\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nexport default class RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket.\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers The optional headers to pass when connecting.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     */\n    constructor(endPoint, options) {\n        var _a;\n        this.accessTokenValue = null;\n        this.apiKey = null;\n        this.channels = [];\n        this.endPoint = '';\n        this.httpEndpoint = '';\n        this.headers = DEFAULT_HEADERS;\n        this.params = {};\n        this.timeout = DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs = 30000;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.ref = 0;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new Serializer();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        this.accessToken = null;\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */\n        this._resolveFetch = (customFetch) => {\n            let _fetch;\n            if (customFetch) {\n                _fetch = customFetch;\n            }\n            else if (typeof fetch === 'undefined') {\n                _fetch = (...args) => import('@supabase/node-fetch').then(({ default: fetch }) => fetch(...args));\n            }\n            else {\n                _fetch = fetch;\n            }\n            return (...args) => _fetch(...args);\n        };\n        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n        this.httpEndpoint = httpEndpointURL(endPoint);\n        if (options === null || options === void 0 ? void 0 : options.transport) {\n            this.transport = options.transport;\n        }\n        else {\n            this.transport = null;\n        }\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.headers)\n            this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n        if (options === null || options === void 0 ? void 0 : options.timeout)\n            this.timeout = options.timeout;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)\n            this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n        const accessTokenValue = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey;\n        if (accessTokenValue) {\n            this.accessTokenValue = accessTokenValue;\n            this.apiKey = accessTokenValue;\n        }\n        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs)\n            ? options.reconnectAfterMs\n            : (tries) => {\n                return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n            };\n        this.encode = (options === null || options === void 0 ? void 0 : options.encode)\n            ? options.encode\n            : (payload, callback) => {\n                return callback(JSON.stringify(payload));\n            };\n        this.decode = (options === null || options === void 0 ? void 0 : options.decode)\n            ? options.decode\n            : this.serializer.decode.bind(this.serializer);\n        this.reconnectTimer = new Timer(async () => {\n            this.disconnect();\n            this.connect();\n        }, this.reconnectAfterMs);\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n        if (options === null || options === void 0 ? void 0 : options.worker) {\n            if (typeof window !== 'undefined' && !window.Worker) {\n                throw new Error('Web Worker is not supported');\n            }\n            this.worker = (options === null || options === void 0 ? void 0 : options.worker) || false;\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n        }\n        this.accessToken = (options === null || options === void 0 ? void 0 : options.accessToken) || null;\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        if (this.conn) {\n            return;\n        }\n        if (this.transport) {\n            this.conn = new this.transport(this.endpointURL(), undefined, {\n                headers: this.headers,\n            });\n            return;\n        }\n        if (NATIVE_WEBSOCKET_AVAILABLE) {\n            this.conn = new WebSocket(this.endpointURL());\n            this.setupConnection();\n            return;\n        }\n        this.conn = new WSWebSocketDummy(this.endpointURL(), undefined, {\n            close: () => {\n                this.conn = null;\n            },\n        });\n        import('ws').then(({ default: WS }) => {\n            this.conn = new WS(this.endpointURL(), undefined, {\n                headers: this.headers,\n            });\n            this.setupConnection();\n        });\n    }\n    /**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */\n    endpointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        if (this.conn) {\n            this.conn.onclose = function () { }; // noop\n            if (code) {\n                this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n            }\n            else {\n                this.conn.close();\n            }\n            this.conn = null;\n            // remove open handles\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.reconnectTimer.reset();\n        }\n    }\n    /**\n     * Returns all created channels\n     */\n    getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n    async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */\n    async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case SOCKET_STATES.connecting:\n                return CONNECTION_STATE.Connecting;\n            case SOCKET_STATES.open:\n                return CONNECTION_STATE.Open;\n            case SOCKET_STATES.closing:\n                return CONNECTION_STATE.Closing;\n            default:\n                return CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === CONNECTION_STATE.Open;\n    }\n    channel(topic, params = { config: {} }) {\n        const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n        this.channels.push(chan);\n        return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * @param token A JWT string to override the token set on the client.\n     */\n    async setAuth(token = null) {\n        let tokenToSend = token ||\n            (this.accessToken && (await this.accessToken())) ||\n            this.accessTokenValue;\n        if (tokenToSend) {\n            let parsed = null;\n            try {\n                parsed = JSON.parse(atob(tokenToSend.split('.')[1]));\n            }\n            catch (_error) { }\n            if (parsed && parsed.exp) {\n                let now = Math.floor(Date.now() / 1000);\n                let valid = now - parsed.exp < 0;\n                if (!valid) {\n                    this.log('auth', `InvalidJWTToken: Invalid value for JWT claim \"exp\" with value ${parsed.exp}`);\n                    return Promise.reject(`InvalidJWTToken: Invalid value for JWT claim \"exp\" with value ${parsed.exp}`);\n                }\n            }\n            this.accessTokenValue = tokenToSend;\n            this.channels.forEach((channel) => {\n                tokenToSend && channel.updateJoinPayload({ access_token: tokenToSend });\n                if (channel.joinedOnce && channel._isJoined()) {\n                    channel._push(CHANNEL_EVENTS.access_token, {\n                        access_token: tokenToSend,\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Sends a heartbeat message if the socket is connected.\n     */\n    async sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            return;\n        }\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n            return;\n        }\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        this.setAuth();\n    }\n    /**\n     * Flushes send buffer\n     */\n    flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n    _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n    _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n    _remove(channel) {\n        this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());\n    }\n    /**\n     * Sets up connection handlers.\n     *\n     * @internal\n     */\n    setupConnection() {\n        if (this.conn) {\n            this.conn.binaryType = 'arraybuffer';\n            this.conn.onopen = () => this._onConnOpen();\n            this.conn.onerror = (error) => this._onConnError(error);\n            this.conn.onmessage = (event) => this._onConnMessage(event);\n            this.conn.onclose = (event) => this._onConnClose(event);\n        }\n    }\n    /** @internal */\n    _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            let { topic, event, payload, ref } = msg;\n            if (ref && ref === this.pendingHeartbeatRef) {\n                this.pendingHeartbeatRef = null;\n            }\n            this.log('receive', `${payload.status || ''} ${topic} ${event} ${(ref && '(' + ref + ')') || ''}`, payload);\n            this.channels\n                .filter((channel) => channel._isMember(topic))\n                .forEach((channel) => channel._trigger(event, payload, ref));\n            this.stateChangeCallbacks.message.forEach((callback) => callback(msg));\n        });\n    }\n    /** @internal */\n    async _onConnOpen() {\n        this.log('transport', `connected to ${this.endpointURL()}`);\n        this.flushSendBuffer();\n        this.reconnectTimer.reset();\n        if (!this.worker) {\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n        }\n        else {\n            if (this.workerUrl) {\n                this.log('worker', `starting worker for from ${this.workerUrl}`);\n            }\n            else {\n                this.log('worker', `starting default worker`);\n            }\n            const objectUrl = this._workerObjectUrl(this.workerUrl);\n            this.workerRef = new Worker(objectUrl);\n            this.workerRef.onerror = (error) => {\n                this.log('worker', 'worker error', error.message);\n                this.workerRef.terminate();\n            };\n            this.workerRef.onmessage = (event) => {\n                if (event.data.event === 'keepAlive') {\n                    this.sendHeartbeat();\n                }\n            };\n            this.workerRef.postMessage({\n                event: 'start',\n                interval: this.heartbeatIntervalMs,\n            });\n        }\n        this.stateChangeCallbacks.open.forEach((callback) => callback());\n    }\n    /** @internal */\n    _onConnClose(event) {\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.scheduleTimeout();\n        this.stateChangeCallbacks.close.forEach((callback) => callback(event));\n    }\n    /** @internal */\n    _onConnError(error) {\n        this.log('transport', error.message);\n        this._triggerChanError();\n        this.stateChangeCallbacks.error.forEach((callback) => callback(error));\n    }\n    /** @internal */\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));\n    }\n    /** @internal */\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _workerObjectUrl(url) {\n        let result_url;\n        if (url) {\n            result_url = url;\n        }\n        else {\n            const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' });\n            result_url = URL.createObjectURL(blob);\n        }\n        return result_url;\n    }\n}\nclass WSWebSocketDummy {\n    constructor(address, _protocols, options) {\n        this.binaryType = 'arraybuffer';\n        this.onclose = () => { };\n        this.onerror = () => { };\n        this.onmessage = () => { };\n        this.onopen = () => { };\n        this.readyState = SOCKET_STATES.connecting;\n        this.send = () => { };\n        this.url = null;\n        this.url = address;\n        this.close = options.close;\n    }\n}\n//# sourceMappingURL=RealtimeClient.js.map"],"file":"assets/js/vendor/vendor-supabase-realtime.PMyDaGD3.js"}