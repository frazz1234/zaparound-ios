{"version":3,"file":"utils-cache.ts.BtmNadnX.js","sources":["../../../../src/utils/cache.ts"],"sourcesContent":["import { LRUCache } from 'lru-cache';\n\n// Cache for API responses\nconst apiCache = new LRUCache<string, any>({\n  max: 500, // Maximum number of items to store\n  ttl: 1000 * 60 * 5, // Time to live: 5 minutes\n  updateAgeOnGet: true, // Update the \"recently used\" status on read\n});\n\n// Cache for user data\nconst userCache = new LRUCache<string, any>({\n  max: 100, // Maximum number of users to cache\n  ttl: 1000 * 60 * 15, // Time to live: 15 minutes\n  updateAgeOnGet: true,\n});\n\n// Cache for blog data\nconst blogCache = new LRUCache<string, any>({\n  max: 200, // Maximum number of blog entries\n  ttl: 1000 * 60 * 30, // Time to live: 30 minutes\n  updateAgeOnGet: true,\n});\n\n// Cache for trip data\nconst tripCache = new LRUCache<string, any>({\n  max: 300, // Maximum number of trips\n  ttl: 1000 * 60 * 10, // Time to live: 10 minutes\n  updateAgeOnGet: true,\n});\n\n// Cache for homepage trip creation flow\nconst homepageCreateTripCache = new LRUCache<string, any>({\n  max: 50, // Maximum number of homepage trip creation flows\n  ttl: 1000 * 60 * 2, // Time to live: 2 minutes (longer to persist through entire flow)\n  updateAgeOnGet: true,\n});\n\nexport interface CacheOptions {\n  ttl?: number;\n  force?: boolean;\n}\n\n// Event-based cache invalidation system\nclass CacheEventManager {\n  private listeners: Map<string, Set<() => void>> = new Map();\n\n  subscribe(event: string, callback: () => void) {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      const eventListeners = this.listeners.get(event);\n      if (eventListeners) {\n        eventListeners.delete(callback);\n        if (eventListeners.size === 0) {\n          this.listeners.delete(event);\n        }\n      }\n    };\n  }\n\n  emit(event: string) {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.forEach(callback => {\n        try {\n          callback();\n        } catch (error) {\n          console.error('Error in cache event callback:', error);\n        }\n      });\n    }\n  }\n}\n\n// Global cache event manager\nexport const cacheEventManager = new CacheEventManager();\n\n// Cache invalidation events\nexport const CACHE_EVENTS = {\n  TRIP_CREATED: 'trip_created',\n  TRIP_UPDATED: 'trip_updated',\n  TRIP_DELETED: 'trip_deleted',\n  FAVORITE_ADDED: 'favorite_added',\n  FAVORITE_REMOVED: 'favorite_removed',\n  FAVORITE_UPDATED: 'favorite_updated',\n  MAP_DATA_INVALIDATED: 'map_data_invalidated',\n  CHECKPOINTS_INVALIDATED: 'checkpoints_invalidated',\n  FAVORITES_INVALIDATED: 'favorites_invalidated',\n  HOMEPAGE_TRIP_CREATION_STARTED: 'homepage_trip_creation_started',\n  HOMEPAGE_TRIP_CREATION_COMPLETED: 'homepage_trip_creation_completed',\n} as const;\n\n/**\n * Generic function to get or set cached data\n * @param cache The LRUCache instance to use\n * @param key The cache key\n * @param fetchFn The function to fetch data if not in cache\n * @param options Cache options\n */\nasync function getOrSetCache<T>(\n  cache: LRUCache<string, T>,\n  key: string,\n  fetchFn: () => Promise<T>,\n  options: CacheOptions = {}\n): Promise<T> {\n  const { force = false, ttl } = options;\n\n  // Return cached data if available and not forced refresh\n  if (!force) {\n    const cached = cache.get(key);\n    if (cached !== undefined) {\n      return cached;\n    }\n  }\n\n  // Fetch fresh data\n  const data = await fetchFn();\n  cache.set(key, data, { ttl });\n  return data;\n}\n\n/**\n * Invalidate all trip-related caches for a user\n */\nexport const invalidateTripCaches = async (userId: string) => {\n  try {\n    // Clear specific cache keys\n    const cacheKeys = [\n      `map-data-${userId}`,\n      `trips-${userId}`,\n    ];\n    \n    cacheKeys.forEach(key => {\n      tripCache.delete(key);\n    });\n    \n    // Clear all checkpoint caches\n    const allKeys = Array.from(tripCache.keys());\n    allKeys.forEach(key => {\n      if (key.includes('-checkpoints-')) {\n        tripCache.delete(key);\n      }\n    });\n    \n    // Emit events to notify all components\n    cacheEventManager.emit(CACHE_EVENTS.TRIP_CREATED);\n    cacheEventManager.emit(CACHE_EVENTS.MAP_DATA_INVALIDATED);\n    cacheEventManager.emit(CACHE_EVENTS.CHECKPOINTS_INVALIDATED);\n    \n    console.log('All trip-related caches invalidated for user:', userId);\n  } catch (error) {\n    console.error('Error invalidating trip caches:', error);\n  }\n};\n\n/**\n * Invalidate all favorite-related caches for a user\n */\nexport const invalidateFavoriteCaches = async (userId: string) => {\n  try {\n    // Clear specific cache keys\n    const cacheKeys = [\n      `map-data-${userId}`,\n      `favorites-${userId}`,\n    ];\n    \n    cacheKeys.forEach(key => {\n      tripCache.delete(key);\n    });\n    \n    // Emit events to notify all components\n    cacheEventManager.emit(CACHE_EVENTS.FAVORITES_INVALIDATED);\n    cacheEventManager.emit(CACHE_EVENTS.MAP_DATA_INVALIDATED);\n    \n    console.log('All favorite-related caches invalidated for user:', userId);\n  } catch (error) {\n    console.error('Error invalidating favorite caches:', error);\n  }\n};\n\n/**\n * Invalidate all caches for a user (trips and favorites)\n */\nexport const invalidateAllCaches = async (userId: string) => {\n  try {\n    // Clear specific cache keys\n    const cacheKeys = [\n      `map-data-${userId}`,\n      `trips-${userId}`,\n      `favorites-${userId}`,\n    ];\n    \n    cacheKeys.forEach(key => {\n      tripCache.delete(key);\n    });\n    \n    // Clear all checkpoint caches\n    const allKeys = Array.from(tripCache.keys());\n    allKeys.forEach(key => {\n      if (key.includes('-checkpoints-')) {\n        tripCache.delete(key);\n      }\n    });\n    \n    // Emit events to notify all components\n    cacheEventManager.emit(CACHE_EVENTS.TRIP_CREATED);\n    cacheEventManager.emit(CACHE_EVENTS.FAVORITES_INVALIDATED);\n    cacheEventManager.emit(CACHE_EVENTS.MAP_DATA_INVALIDATED);\n    cacheEventManager.emit(CACHE_EVENTS.CHECKPOINTS_INVALIDATED);\n    \n    console.log('All caches invalidated for user:', userId);\n  } catch (error) {\n    console.error('Error invalidating all caches:', error);\n  }\n};\n\n/**\n * Invalidate specific cache by key\n */\nexport const invalidateCacheByKey = (cache: LRUCache<string, any>, key: string) => {\n  cache.delete(key);\n  console.log(`Cache invalidated for key: ${key}`);\n};\n\n/**\n * Clear all caches\n */\nexport const clearAllCaches = () => {\n  apiCache.clear();\n  userCache.clear();\n  blogCache.clear();\n  tripCache.clear();\n  console.log('All caches cleared');\n};\n\n/**\n * Set homepage trip creation cache\n */\nexport const setHomepageCreateTripCache = (userId: string, activityData: any) => {\n  const key = `homepage-create-trip-${userId}`;\n  const cacheData = {\n    ...activityData,\n    timestamp: Date.now(),\n    userId,\n  };\n  homepageCreateTripCache.set(key, cacheData);\n  \n  // Emit event for any listeners\n  cacheEventManager.emit(CACHE_EVENTS.HOMEPAGE_TRIP_CREATION_STARTED);\n  \n  return key;\n};\n\n/**\n * Get homepage trip creation cache\n */\nexport const getHomepageCreateTripCache = (userId: string) => {\n  const key = `homepage-create-trip-${userId}`;\n  const cached = homepageCreateTripCache.get(key);\n  return cached;\n};\n\n/**\n * Remove homepage trip creation cache\n */\nexport const removeHomepageCreateTripCache = (userId: string) => {\n  const key = `homepage-create-trip-${userId}`;\n  const existed = homepageCreateTripCache.has(key);\n  homepageCreateTripCache.delete(key);\n  \n  if (existed) {\n    // Emit event for any listeners\n    cacheEventManager.emit(CACHE_EVENTS.HOMEPAGE_TRIP_CREATION_COMPLETED);\n  }\n  \n  return existed;\n};\n\n/**\n * Check if homepage trip creation cache exists\n */\nexport const hasHomepageCreateTripCache = (userId: string) => {\n  const key = `homepage-create-trip-${userId}`;\n  const hasCache = homepageCreateTripCache.has(key);\n  \n  // Also check for temporary cache in sessionStorage\n  let hasTempCache = false;\n  try {\n    const tempCache = sessionStorage.getItem('homepage-create-trip-temp');\n    hasTempCache = !!tempCache;\n    if (hasTempCache && hasCache === false) {\n      // Transfer temp cache to permanent cache for authenticated user\n      const tempData = JSON.parse(tempCache);\n      setHomepageCreateTripCache(userId, { ...tempData, transferredFromTemp: true });\n      // Remove temp cache\n      sessionStorage.removeItem('homepage-create-trip-temp');\n      return true;\n    }\n  } catch (error) {\n    // Silently handle temp cache errors\n  }\n  \n  return hasCache || hasTempCache;\n};\n\nexport {\n  apiCache,\n  userCache,\n  blogCache,\n  tripCache,\n  homepageCreateTripCache,\n  getOrSetCache,\n}; "],"names":["LRUCache","max","ttl","updateAgeOnGet","userCache","blogCache","tripCache","homepageCreateTripCache","cacheEventManager","listeners","Map","subscribe","event","callback","this","has","set","Set","get","add","eventListeners","delete","size","emit","forEach","error","CACHE_EVENTS","TRIP_CREATED","TRIP_UPDATED","TRIP_DELETED","FAVORITE_ADDED","FAVORITE_REMOVED","FAVORITE_UPDATED","MAP_DATA_INVALIDATED","CHECKPOINTS_INVALIDATED","FAVORITES_INVALIDATED","HOMEPAGE_TRIP_CREATION_STARTED","HOMEPAGE_TRIP_CREATION_COMPLETED","async","getOrSetCache","cache","key","fetchFn","options","force","cached","data","invalidateTripCaches","userId","Array","from","keys","includes","invalidateFavoriteCaches","setHomepageCreateTripCache","activityData","cacheData","timestamp","Date","now","removeHomepageCreateTripCache","existed","hasHomepageCreateTripCache","hasCache","hasTempCache","tempCache","sessionStorage","getItem","tempData","JSON","parse","transferredFromTemp","removeItem"],"mappings":"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"}