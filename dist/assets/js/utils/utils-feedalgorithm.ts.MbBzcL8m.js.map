{"version":3,"file":"utils-feedalgorithm.ts.MbBzcL8m.js","sources":["../../../../src/utils/feedAlgorithm.ts"],"sourcesContent":["import { supabase } from '@/integrations/supabase/client';\n\nexport interface FeedPost {\n  id: number;\n  user_id: string;\n  content: string;\n  media_urls?: any[];\n  image_url?: string;\n  location?: string;\n  place_id?: string;\n  place_lat?: number;\n  place_lng?: number;\n  place_types?: string[];\n  place_rating?: number;\n  place_user_ratings_total?: number;\n  post_type?: 'activity' | 'destination';\n  rating?: number;\n  created_at: string;\n  updated_at: string;\n  is_published: boolean;\n  profile?: {\n    username?: string;\n    first_name?: string;\n    last_name?: string;\n    avatar_url?: string;\n  };\n  likes?: Array<{ count: number }>;\n  replies?: Array<{ count: number }>;\n  // Calculated scores\n  distance?: number;\n  popularity_score?: number;\n  recency_score?: number;\n  engagement_score?: number;\n  final_score?: number;\n}\n\nexport interface UserLocation {\n  lat: number;\n  lng: number;\n}\n\n// Configuration des poids pour l'algorithme\nconst WEIGHTS = {\n  RECENCY: 0.3,        // 30% - Les posts récents sont plus importants\n  PROXIMITY: 0.25,     // 25% - La proximité géographique\n  POPULARITY: 0.25,    // 25% - Popularité basée sur likes/réponses\n  ENGAGEMENT: 0.2      // 20% - Taux d'engagement (likes + réponses)\n};\n\n// Rayons de proximité en km\nconst PROXIMITY_RADIUS = [50, 100, 200, 500, 1000];\n\nexport class FeedAlgorithm {\n  private userLocation: UserLocation | null = null;\n\n  constructor(userLocation?: UserLocation) {\n    this.userLocation = userLocation || null;\n  }\n\n  // Calcule la distance entre deux points (formule de Haversine)\n  private calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\n    const R = 6371; // Rayon de la Terre en km\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = \n      Math.sin(dLat/2) * Math.sin(dLat/2) +\n      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * \n      Math.sin(dLng/2) * Math.sin(dLng/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    return R * c;\n  }\n\n  // Calcule le score de récence (0-1)\n  private calculateRecencyScore(createdAt: string): number {\n    const now = new Date();\n    const postDate = new Date(createdAt);\n    const hoursDiff = (now.getTime() - postDate.getTime()) / (1000 * 60 * 60);\n    \n    // Score décroît exponentiellement avec le temps\n    // Posts de moins de 1h = score 1, posts de 24h = score ~0.37\n    return Math.exp(-hoursDiff / 24);\n  }\n\n  // Calcule le score de proximité (0-1)\n  private calculateProximityScore(distance: number): number {\n    if (!this.userLocation || distance === undefined) return 0.5; // Score neutre si pas de localisation\n    \n    // Score basé sur les rayons de proximité\n    if (distance <= 50) return 1.0;      // Très proche\n    if (distance <= 100) return 0.9;     // Proche\n    if (distance <= 200) return 0.8;     // Régional\n    if (distance <= 500) return 0.6;     // National\n    if (distance <= 1000) return 0.4;    // Continental\n    return 0.3;                          // Around the World (augmenté pour encourager la découverte)\n  }\n\n  // Vérifie si un post est \"Around the World\" (>1000km)\n  private isAroundTheWorld(distance: number): boolean {\n    return distance > 1000;\n  }\n\n  // Calcule le score de popularité (0-1)\n  private calculatePopularityScore(likes: number, replies: number): number {\n    const totalEngagement = likes + replies;\n    \n    // Score logarithmique pour éviter que les posts très populaires dominent\n    return Math.min(1, Math.log10(totalEngagement + 1) / 3);\n  }\n\n  // Calcule le score d'engagement (0-1)\n  private calculateEngagementScore(likes: number, replies: number): number {\n    const totalEngagement = likes + replies;\n    const engagementRate = totalEngagement / 10; // Normalisé sur 10 interactions\n    \n    return Math.min(1, engagementRate);\n  }\n\n  // Calcule le score final pour un post\n  private calculateFinalScore(post: FeedPost): number {\n    const recencyScore = this.calculateRecencyScore(post.created_at);\n    const proximityScore = this.calculateProximityScore(post.distance || 0);\n    const popularityScore = this.calculatePopularityScore(\n      post.likes?.[0]?.count || 0,\n      post.replies?.[0]?.count || 0\n    );\n    const engagementScore = this.calculateEngagementScore(\n      post.likes?.[0]?.count || 0,\n      post.replies?.[0]?.count || 0\n    );\n\n    // Calcul du score final pondéré\n    const finalScore = \n      recencyScore * WEIGHTS.RECENCY +\n      proximityScore * WEIGHTS.PROXIMITY +\n      popularityScore * WEIGHTS.POPULARITY +\n      engagementScore * WEIGHTS.ENGAGEMENT;\n\n    return finalScore;\n  }\n\n  // Récupère et trie les posts selon l'algorithme\n  async getFeedPosts(page: number = 1, limit: number = 15): Promise<FeedPost[]> {\n    try {\n      // 1. Récupérer tous les posts avec leurs métadonnées\n      let query = supabase\n        .from('community_posts')\n        .select(`\n          *,\n          likes:post_likes(count),\n          replies:post_replies(count),\n          profile:profiles!user_id (\n            username,\n            first_name,\n            last_name,\n            avatar_url\n          )\n        `)\n        .eq('is_published', true)\n        .order('created_at', { ascending: false });\n\n      const { data: posts, error } = await query;\n\n      if (error) throw error;\n\n      // 2. Calculer les distances et scores pour chaque post\n      const postsWithScores: FeedPost[] = posts.map(post => {\n        let distance = undefined;\n        \n        // Calculer la distance si on a la localisation de l'utilisateur\n        if (this.userLocation && post.place_lat && post.place_lng) {\n          distance = this.calculateDistance(\n            this.userLocation.lat,\n            this.userLocation.lng,\n            post.place_lat,\n            post.place_lng\n          );\n        }\n\n        const postWithScores: FeedPost = {\n          ...post,\n          distance,\n          recency_score: this.calculateRecencyScore(post.created_at),\n          popularity_score: this.calculatePopularityScore(\n            post.likes?.[0]?.count || 0,\n            post.replies?.[0]?.count || 0\n          ),\n          engagement_score: this.calculateEngagementScore(\n            post.likes?.[0]?.count || 0,\n            post.replies?.[0]?.count || 0\n          )\n        };\n\n        postWithScores.final_score = this.calculateFinalScore(postWithScores);\n        \n        return postWithScores;\n      });\n\n      // 3. Trier par score final décroissant\n      postsWithScores.sort((a, b) => (b.final_score || 0) - (a.final_score || 0));\n\n      // 4. Appliquer la pagination\n      const startIndex = (page - 1) * limit;\n      const endIndex = startIndex + limit;\n      \n      return postsWithScores.slice(startIndex, endIndex);\n\n    } catch (error) {\n      console.error('Error fetching feed posts:', error);\n      return [];\n    }\n  }\n\n  // Récupère les posts populaires (posts avec beaucoup d'engagement)\n  async getPopularPosts(limit: number = 10): Promise<FeedPost[]> {\n    try {\n      const { data: posts, error } = await supabase\n        .from('community_posts')\n        .select(`\n          *,\n          likes:post_likes(count),\n          replies:post_replies(count),\n          profile:profiles!user_id (\n            username,\n            first_name,\n            last_name,\n            avatar_url\n          )\n        `)\n        .eq('is_published', true)\n        .order('created_at', { ascending: false })\n        .limit(limit * 2); // Récupérer plus pour filtrer\n\n      if (error) throw error;\n\n      // Calculer les scores et trier par popularité\n      const postsWithScores = posts.map(post => ({\n        ...post,\n        popularity_score: this.calculatePopularityScore(\n          post.likes?.[0]?.count || 0,\n          post.replies?.[0]?.count || 0\n        )\n      }));\n\n      postsWithScores.sort((a, b) => (b.popularity_score || 0) - (a.popularity_score || 0));\n      \n      return postsWithScores.slice(0, limit);\n\n    } catch (error) {\n      console.error('Error fetching popular posts:', error);\n      return [];\n    }\n  }\n\n  // Récupère les posts récents (posts des dernières 24h)\n  async getRecentPosts(limit: number = 10): Promise<FeedPost[]> {\n    try {\n      const yesterday = new Date();\n      yesterday.setDate(yesterday.getDate() - 1);\n\n      const { data: posts, error } = await supabase\n        .from('community_posts')\n        .select(`\n          *,\n          likes:post_likes(count),\n          replies:post_replies(count),\n          profile:profiles!user_id (\n            username,\n            first_name,\n            last_name,\n            avatar_url\n          )\n        `)\n        .eq('is_published', true)\n        .gte('created_at', yesterday.toISOString())\n        .order('created_at', { ascending: false })\n        .limit(limit);\n\n      if (error) throw error;\n\n      return posts;\n\n    } catch (error) {\n      console.error('Error fetching recent posts:', error);\n      return [];\n    }\n  }\n\n  // Récupère les destinations populaires et récentes (optimisé pour les destinations)\n  async getDestinationPosts(page: number = 1, limit: number = 15): Promise<FeedPost[]> {\n    try {\n      // Récupérer plus de posts pour avoir un bon échantillon\n      const { data: posts, error } = await supabase\n        .from('community_posts')\n        .select(`\n          *,\n          likes:post_likes(count),\n          replies:post_replies(count),\n          profile:profiles!user_id (\n            username,\n            first_name,\n            last_name,\n            avatar_url\n          )\n        `)\n        .eq('is_published', true)\n        .eq('post_type', 'destination')\n        .order('created_at', { ascending: false })\n        .limit(limit * 3); // Récupérer plus pour avoir un bon tri\n\n      if (error) throw error;\n\n      // Calculer les scores pour chaque destination\n      const postsWithScores: FeedPost[] = posts.map(post => {\n        let distance = undefined;\n        \n        if (this.userLocation && post.place_lat && post.place_lng) {\n          distance = this.calculateDistance(\n            this.userLocation.lat,\n            this.userLocation.lng,\n            post.place_lat,\n            post.place_lng\n          );\n        }\n\n        const popularityScore = this.calculatePopularityScore(\n          post.likes?.[0]?.count || 0,\n          post.replies?.[0]?.count || 0\n        );\n        const recencyScore = this.calculateRecencyScore(post.created_at);\n        const proximityScore = this.calculateProximityScore(distance || 0);\n\n        // Score spécial pour les destinations: plus de poids sur popularité et récence\n        const destinationScore = \n          (popularityScore * 0.4) +      // 40% popularité\n          (recencyScore * 0.35) +        // 35% récence\n          (proximityScore * 0.25);       // 25% proximité\n\n        return {\n          ...post,\n          distance,\n          popularity_score: popularityScore,\n          recency_score: recencyScore,\n          engagement_score: this.calculateEngagementScore(\n            post.likes?.[0]?.count || 0,\n            post.replies?.[0]?.count || 0\n          ),\n          final_score: destinationScore\n        };\n      });\n\n      // Trier par score de destination\n      postsWithScores.sort((a, b) => (b.final_score || 0) - (a.final_score || 0));\n\n      // Appliquer la pagination\n      const startIndex = (page - 1) * limit;\n      const endIndex = startIndex + limit;\n      \n      return postsWithScores.slice(startIndex, endIndex);\n\n    } catch (error) {\n      console.error('Error fetching destination posts:', error);\n      return [];\n    }\n  }\n\n  // Récupère les posts \"Around the World\" (>1000km)\n  async getAroundTheWorldPosts(page: number = 1, limit: number = 15): Promise<FeedPost[]> {\n    try {\n      const { data: posts, error } = await supabase\n        .from('community_posts')\n        .select(`\n          *,\n          likes:post_likes(count),\n          replies:post_replies(count),\n          profile:profiles!user_id (\n            username,\n            first_name,\n            last_name,\n            avatar_url\n          )\n        `)\n        .eq('is_published', true)\n        .order('created_at', { ascending: false })\n        .limit(limit * 2);\n\n      if (error) throw error;\n\n      // Filtrer et calculer les scores pour les posts >1000km\n      const aroundTheWorldPosts: FeedPost[] = posts\n        .map(post => {\n          let distance = undefined;\n          \n          if (this.userLocation && post.place_lat && post.place_lng) {\n            distance = this.calculateDistance(\n              this.userLocation.lat,\n              this.userLocation.lng,\n              post.place_lat,\n              post.place_lng\n            );\n          }\n\n          return {\n            ...post,\n            distance,\n            popularity_score: this.calculatePopularityScore(\n              post.likes?.[0]?.count || 0,\n              post.replies?.[0]?.count || 0\n            ),\n            recency_score: this.calculateRecencyScore(post.created_at),\n            engagement_score: this.calculateEngagementScore(\n              post.likes?.[0]?.count || 0,\n              post.replies?.[0]?.count || 0\n            )\n          };\n        })\n        .filter(post => post.distance && post.distance > 1000)\n        .map(post => ({\n          ...post,\n          final_score: this.calculateFinalScore(post)\n        }));\n\n      // Trier par score final\n      aroundTheWorldPosts.sort((a, b) => (b.final_score || 0) - (a.final_score || 0));\n\n      // Appliquer la pagination\n      const startIndex = (page - 1) * limit;\n      const endIndex = startIndex + limit;\n      \n      return aroundTheWorldPosts.slice(startIndex, endIndex);\n\n    } catch (error) {\n      console.error('Error fetching around the world posts:', error);\n      return [];\n    }\n  }\n\n  // Met à jour la localisation de l'utilisateur\n  updateUserLocation(location: UserLocation) {\n    this.userLocation = location;\n  }\n}\n\n// Fonction utilitaire pour obtenir les posts du feed\nexport const getFeedPosts = async (\n  userLocation?: UserLocation,\n  page: number = 1,\n  limit: number = 15\n): Promise<FeedPost[]> => {\n  const algorithm = new FeedAlgorithm(userLocation);\n  return algorithm.getFeedPosts(page, limit);\n};\n\n// Fonction utilitaire pour obtenir les posts populaires\nexport const getPopularPosts = async (\n  limit: number = 10\n): Promise<FeedPost[]> => {\n  const algorithm = new FeedAlgorithm();\n  return algorithm.getPopularPosts(limit);\n};\n\n// Fonction utilitaire pour obtenir les posts récents\nexport const getRecentPosts = async (\n  limit: number = 10\n): Promise<FeedPost[]> => {\n  const algorithm = new FeedAlgorithm();\n  return algorithm.getRecentPosts(limit);\n};\n\n// Fonction utilitaire pour obtenir les destinations optimisées\nexport const getDestinationPosts = async (\n  userLocation?: UserLocation,\n  page: number = 1,\n  limit: number = 15\n): Promise<FeedPost[]> => {\n  const algorithm = new FeedAlgorithm(userLocation);\n  return algorithm.getDestinationPosts(page, limit);\n};\n\n// Fonction utilitaire pour obtenir les posts \"Around the World\"\nexport const getAroundTheWorldPosts = async (\n  userLocation?: UserLocation,\n  page: number = 1,\n  limit: number = 15\n): Promise<FeedPost[]> => {\n  const algorithm = new FeedAlgorithm(userLocation);\n  return algorithm.getAroundTheWorldPosts(page, limit);\n}; "],"names":["WEIGHTS","FeedAlgorithm","userLocation","constructor","this","calculateDistance","lat1","lng1","lat2","lng2","dLat","Math","PI","dLng","a","sin","cos","atan2","sqrt","calculateRecencyScore","createdAt","now","Date","postDate","hoursDiff","getTime","exp","calculateProximityScore","distance","isAroundTheWorld","calculatePopularityScore","likes","replies","totalEngagement","min","log10","calculateEngagementScore","engagementRate","calculateFinalScore","post","recencyScore","created_at","proximityScore","popularityScore","count","engagementScore","getFeedPosts","page","limit","query","supabase","from","select","eq","order","ascending","data","posts","error","postsWithScores","map","place_lat","place_lng","lat","lng","postWithScores","recency_score","popularity_score","engagement_score","final_score","sort","b","startIndex","endIndex","slice","getPopularPosts","getRecentPosts","yesterday","setDate","getDate","gte","toISOString","getDestinationPosts","destinationScore","getAroundTheWorldPosts","aroundTheWorldPosts","filter","updateUserLocation","location"],"mappings":"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"}