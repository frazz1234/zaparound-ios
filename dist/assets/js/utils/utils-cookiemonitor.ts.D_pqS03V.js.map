{"version":3,"file":"utils-cookiemonitor.ts.D_pqS03V.js","sources":["../../../../src/utils/cookieMonitor.ts"],"sourcesContent":["import { getCookie, deleteCookie } from './cookieManager';\n\n// Browser cookie limits (in bytes)\nconst COOKIE_LIMITS = {\n  TOTAL_SIZE: 4096, // 4KB per cookie\n  TOTAL_NUMBER: 50, // Maximum number of cookies per domain\n  DOMAIN_SIZE: 4096 * 50, // Total size for all cookies per domain\n  UPDATE_THROTTLE: 1000, // Minimum time between updates in ms\n  DEBOUNCE_DELAY: 300, // Debounce delay for rapid updates\n};\n\n// Cookie inventory to track all cookies\ninterface CookieInfo {\n  name: string;\n  size: number;\n  expires?: Date;\n  category: 'necessary' | 'functional' | 'analytics' | 'marketing';\n  lastAccessed: Date;\n}\n\nclass CookieMonitor {\n  private cookieInventory: Map<string, CookieInfo> = new Map();\n  private static instance: CookieMonitor;\n  private lastUpdateTime: number = 0;\n  private updateTimeout: NodeJS.Timeout | null = null;\n  private cachedTotalSize: number | null = null;\n  private cachedCategoryCounts: Record<CookieInfo['category'], number> | null = null;\n\n  private constructor() {\n    // Initialize the cookie inventory\n    this.updateInventory();\n    \n    // Set up periodic cleanup and monitoring\n    setInterval(() => {\n      this.cleanupExpiredCookies();\n      this.checkCookieLimits();\n    }, 1000 * 60 * 60); // Run every hour\n\n    // Listen for cookie changes\n    document.addEventListener('cookie-changed', this.debouncedUpdate);\n  }\n\n  private debouncedUpdate = () => {\n    if (this.updateTimeout) {\n      clearTimeout(this.updateTimeout);\n    }\n    this.updateTimeout = setTimeout(() => {\n      this.updateInventory();\n    }, COOKIE_LIMITS.DEBOUNCE_DELAY);\n  };\n\n  public static getInstance(): CookieMonitor {\n    if (!CookieMonitor.instance) {\n      CookieMonitor.instance = new CookieMonitor();\n    }\n    return CookieMonitor.instance;\n  }\n\n  // Update the cookie inventory\n  private updateInventory(): void {\n    const now = Date.now();\n    if (now - this.lastUpdateTime < COOKIE_LIMITS.UPDATE_THROTTLE) {\n      return; // Skip update if too soon\n    }\n    this.lastUpdateTime = now;\n\n    try {\n      const cookies = document.cookie.split(';');\n      const newInventory = new Map<string, CookieInfo>();\n      \n      cookies.forEach(cookie => {\n        const [name, value] = cookie.trim().split('=');\n        const decodedName = decodeURIComponent(name);\n        const decodedValue = decodeURIComponent(value);\n        \n        // Reuse existing cookie info if available\n        const existingInfo = this.cookieInventory.get(decodedName);\n        const cookieInfo: CookieInfo = {\n          name: decodedName,\n          size: new Blob([cookie]).size,\n          lastAccessed: existingInfo?.lastAccessed || new Date(),\n          category: existingInfo?.category || this.determineCookieCategory(decodedName)\n        };\n        \n        newInventory.set(decodedName, cookieInfo);\n      });\n      \n      this.cookieInventory = newInventory;\n      \n      // Invalidate caches\n      this.cachedTotalSize = null;\n      this.cachedCategoryCounts = null;\n      \n      // Log inventory update\n      console.debug('Cookie inventory updated:', \n        Array.from(this.cookieInventory.entries())\n          .map(([name, info]) => ({ name, size: info.size }))\n      );\n    } catch (error) {\n      console.error('Error updating cookie inventory:', error);\n    }\n  }\n\n  // Determine cookie category based on name\n  private determineCookieCategory(name: string): CookieInfo['category'] {\n    if (this.isNecessaryCookie(name)) return 'necessary';\n    if (this.isFunctionalCookie(name)) return 'functional';\n    if (this.isAnalyticsCookie(name)) return 'analytics';\n    if (this.isMarketingCookie(name)) return 'marketing';\n    return 'necessary'; // Default to necessary if unknown\n  }\n\n  // Check if cookie is necessary\n  private isNecessaryCookie(name: string): boolean {\n    const necessaryCookies = [\n      'zaparound-cookie-consent',\n      'session',\n      'csrf',\n      'auth',\n      'sb-',\n    ];\n    return necessaryCookies.some(prefix => name.startsWith(prefix));\n  }\n\n  // Check if cookie is functional\n  private isFunctionalCookie(name: string): boolean {\n    const functionalCookies = [\n      'theme',\n      'language',\n      'app-language',\n      'preferences',\n      'ui-',\n    ];\n    return functionalCookies.some(prefix => name.startsWith(prefix));\n  }\n\n  // Check if cookie is analytics\n  private isAnalyticsCookie(name: string): boolean {\n    const analyticsCookies = [\n      '_ga',\n      '_gid',\n      '_gat',\n      'plausible_',\n      'amplitude_',\n      'mixpanel_',\n    ];\n    return analyticsCookies.some(prefix => name.startsWith(prefix));\n  }\n\n  // Check if cookie is marketing\n  private isMarketingCookie(name: string): boolean {\n    const marketingCookies = [\n      '_fbp',\n      '_gcl',\n      'ads_',\n      'marketing_',\n    ];\n    return marketingCookies.some(prefix => name.startsWith(prefix));\n  }\n\n  // Clean up expired cookies\n  public cleanupExpiredCookies(): void {\n    try {\n      let cleanupCount = 0;\n      const now = new Date();\n      \n      this.cookieInventory.forEach((info, name) => {\n        if (info.expires && info.expires < now) {\n          deleteCookie(name);\n          this.cookieInventory.delete(name);\n          cleanupCount++;\n        }\n      });\n      \n      if (cleanupCount > 0) {\n        console.debug(`Cleaned up ${cleanupCount} expired cookies`);\n        this.updateInventory();\n      }\n    } catch (error) {\n      console.error('Error cleaning up expired cookies:', error);\n    }\n  }\n\n  // Check cookie size limits\n  public checkCookieLimits(): void {\n    try {\n      let totalSize = 0;\n      const cookieCount = this.cookieInventory.size;\n      \n      this.cookieInventory.forEach(info => {\n        totalSize += info.size;\n        \n        // Check individual cookie size\n        if (info.size > COOKIE_LIMITS.TOTAL_SIZE) {\n          console.warn(`Cookie \"${info.name}\" exceeds size limit:`, {\n            size: info.size,\n            limit: COOKIE_LIMITS.TOTAL_SIZE\n          });\n        }\n      });\n      \n      // Check total number of cookies\n      if (cookieCount > COOKIE_LIMITS.TOTAL_NUMBER) {\n        console.warn('Total number of cookies exceeds limit:', {\n          count: cookieCount,\n          limit: COOKIE_LIMITS.TOTAL_NUMBER\n        });\n      }\n      \n      // Check total size of all cookies\n      if (totalSize > COOKIE_LIMITS.DOMAIN_SIZE) {\n        console.warn('Total cookie size exceeds domain limit:', {\n          size: totalSize,\n          limit: COOKIE_LIMITS.DOMAIN_SIZE\n        });\n      }\n    } catch (error) {\n      console.error('Error checking cookie limits:', error);\n    }\n  }\n\n  // Get cookie inventory\n  public getInventory(): Map<string, CookieInfo> {\n    return new Map(this.cookieInventory);\n  }\n\n  // Get total cookie size with memoization\n  public getTotalSize(): number {\n    if (this.cachedTotalSize === null) {\n      let totalSize = 0;\n      this.cookieInventory.forEach(info => {\n        totalSize += info.size;\n      });\n      this.cachedTotalSize = totalSize;\n    }\n    return this.cachedTotalSize;\n  }\n\n  // Get cookie count by category with memoization\n  public getCookieCountByCategory(): Record<CookieInfo['category'], number> {\n    if (this.cachedCategoryCounts === null) {\n      const counts = {\n        necessary: 0,\n        functional: 0,\n        analytics: 0,\n        marketing: 0\n      };\n      \n      this.cookieInventory.forEach(info => {\n        counts[info.category]++;\n      });\n      \n      this.cachedCategoryCounts = counts;\n    }\n    return { ...this.cachedCategoryCounts };\n  }\n\n  // Update cookie access time\n  public updateCookieAccess(name: string): void {\n    const cookie = this.cookieInventory.get(name);\n    if (cookie) {\n      cookie.lastAccessed = new Date();\n      this.cookieInventory.set(name, cookie);\n    }\n  }\n\n  // Clean up resources when the monitor is no longer needed\n  public destroy(): void {\n    if (this.updateTimeout) {\n      clearTimeout(this.updateTimeout);\n    }\n    document.removeEventListener('cookie-changed', this.debouncedUpdate);\n  }\n}\n\nexport const cookieMonitor = CookieMonitor.getInstance(); "],"names":["COOKIE_LIMITS","CookieMonitor","cookieInventory","Map","static","lastUpdateTime","updateTimeout","cachedTotalSize","cachedCategoryCounts","constructor","this","updateInventory","setInterval","cleanupExpiredCookies","checkCookieLimits","document","addEventListener","debouncedUpdate","clearTimeout","setTimeout","getInstance","instance","now","Date","cookies","cookie","split","newInventory","forEach","name","value","trim","decodedName","decodeURIComponent","existingInfo","get","cookieInfo","size","Blob","lastAccessed","category","determineCookieCategory","set","error","isNecessaryCookie","isFunctionalCookie","isAnalyticsCookie","isMarketingCookie","some","prefix","startsWith","cleanupCount","info","expires","deleteCookie","delete","totalSize","getInventory","getTotalSize","getCookieCountByCategory","counts","necessary","functional","analytics","marketing","updateCookieAccess","destroy","removeEventListener","cookieMonitor"],"mappings":"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"}