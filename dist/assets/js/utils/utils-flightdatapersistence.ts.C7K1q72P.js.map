{"version":3,"file":"utils-flightdatapersistence.ts.C7K1q72P.js","sources":["../../../../src/utils/flightDataPersistence.ts"],"sourcesContent":["import localforage from 'localforage';\n\n// Flight Data Persistence Utility\n// Implements Google Flights-like logic for data persistence and automatic refresh\n// Uses LocalForage for better storage capacity and reliability\n\nexport interface FlightSearchData {\n  searchParams: {\n    origin: string;\n    destination: string;\n    departureDate: string;\n    returnDate?: string;\n    passengers: number;\n    cabinClass: string;\n    currency: string;\n    maxConnections?: number;\n  };\n  searchResults: any;\n  timing: {\n    search_started_at: string;\n    supplier_timeout: number;\n    expires_at: string | null;\n    created_at: string | null;\n  };\n  searchTimestamp: number;\n  selectedOfferId?: string;\n  userProgress: {\n    currentStep: 'search' | 'passengers' | 'ancillaries' | 'luggage' | 'payment';\n    passengerForms?: any[];\n    ancillariesPayload?: any;\n    luggageSelections?: any;\n  };\n  searchId: string; // Unique identifier for this search\n  needsRefresh?: boolean; // Flag to indicate if data needs refresh\n}\n\nexport interface FlightDataCache {\n  [key: string]: FlightSearchData;\n}\n\nclass FlightDataPersistence {\n  private readonly CACHE_PREFIX = 'flight_search_';\n  private readonly MAX_CACHE_AGE = 30 * 60 * 1000; // 30 minutes\n  private readonly OFFER_EXPIRY_BUFFER = 5 * 60 * 1000; // 5 minutes buffer before expiry\n  private readonly SUPPLIER_TIMEOUT_MULTIPLIER = 3; // 3x supplier timeout for cache age\n  private store: LocalForage;\n\n  constructor() {\n    // Configure LocalForage for flight data storage\n    this.store = localforage.createInstance({\n      name: 'ZapAroundFlightData',\n      storeName: 'flight_searches',\n      description: 'Flight search data and user progress for ZapAround'\n    });\n    \n    // Set preferred driver order: IndexedDB > WebSQL > localStorage\n    this.store.setDriver([\n      localforage.INDEXEDDB,\n      localforage.WEBSQL,\n      localforage.LOCALSTORAGE\n    ]);\n  }\n\n  /**\n   * Generate a unique search ID for URL-based caching\n   */\n  generateSearchId(searchParams: FlightSearchData['searchParams']): string {\n    const {\n      origin,\n      destination,\n      departureDate,\n      returnDate,\n      passengers,\n      cabinClass,\n      currency,\n      maxConnections\n    } = searchParams;\n    \n    const searchString = `${origin}-${destination}-${departureDate}-${returnDate || 'oneway'}-${passengers}-${cabinClass}-${currency}-${maxConnections || 1}`;\n    return btoa(searchString).replace(/[^a-zA-Z0-9]/g, '').substring(0, 12);\n  }\n\n  /**\n   * Create a search URL with parameters\n   */\n  createSearchUrl(searchParams: FlightSearchData['searchParams'], language: string = 'en'): string {\n    const searchId = this.generateSearchId(searchParams);\n    const params = new URLSearchParams({\n      origin: searchParams.origin,\n      destination: searchParams.destination,\n      departureDate: searchParams.departureDate,\n      passengers: searchParams.passengers.toString(),\n      cabinClass: searchParams.cabinClass,\n      currency: searchParams.currency,\n      searchId: searchId\n    });\n    \n    if (searchParams.returnDate) {\n      params.append('returnDate', searchParams.returnDate);\n    }\n    if (searchParams.maxConnections) {\n      params.append('maxConnections', searchParams.maxConnections.toString());\n    }\n    \n    return `/${language}/booking/flights?${params.toString()}`;\n  }\n\n  /**\n   * Create a flight details URL with search context\n   */\n  createFlightDetailsUrl(offerId: string, searchParams: FlightSearchData['searchParams'], language: string = 'en'): string {\n    const searchId = this.generateSearchId(searchParams);\n    return `/${language}/booking/flight-details?offerId=${offerId}&searchId=${searchId}`;\n  }\n\n  /**\n   * Extract search parameters from URL\n   */\n  extractSearchParamsFromUrl(url: string): FlightSearchData['searchParams'] | null {\n    try {\n      const urlObj = new URL(url, window.location.origin);\n      const params = urlObj.searchParams;\n      \n      const origin = params.get('origin');\n      const destination = params.get('destination');\n      const departureDate = params.get('departureDate');\n      const returnDate = params.get('returnDate') || undefined;\n      const passengers = parseInt(params.get('passengers') || '1');\n      const cabinClass = params.get('cabinClass') || 'economy';\n      const currency = params.get('currency') || 'USD';\n      const maxConnections = params.get('maxConnections') ? parseInt(params.get('maxConnections')!) : 1;\n      \n      if (!origin || !destination || !departureDate) {\n        return null;\n      }\n      \n      return {\n        origin,\n        destination,\n        departureDate,\n        returnDate,\n        passengers,\n        cabinClass,\n        currency,\n        maxConnections\n      };\n    } catch (error) {\n      console.error('Error extracting search params from URL:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get search ID from URL\n   */\n  getSearchIdFromUrl(url: string): string | null {\n    try {\n      const urlObj = new URL(url, window.location.origin);\n      return urlObj.searchParams.get('searchId');\n    } catch (error) {\n      console.error('Error getting search ID from URL:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Check if offers are expired based on Duffel API timing\n   */\n  private isOffersExpired(timing: FlightSearchData['timing']): boolean {\n    if (!timing.expires_at) return false;\n    \n    const now = new Date().getTime();\n    const expiryTime = new Date(timing.expires_at).getTime();\n    const bufferTime = expiryTime - this.OFFER_EXPIRY_BUFFER;\n    \n    return now >= bufferTime;\n  }\n\n  /**\n   * Check if search data is stale based on search timestamp and supplier timeout\n   */\n  private isSearchDataStale(searchData: FlightSearchData): boolean {\n    const now = Date.now();\n    const searchAge = now - searchData.searchTimestamp;\n    \n    // Use supplier timeout if available, otherwise default to 30 minutes\n    const supplierTimeout = searchData.timing.supplier_timeout || 20000; // 20 seconds default\n    const maxAge = Math.max(supplierTimeout * this.SUPPLIER_TIMEOUT_MULTIPLIER, this.MAX_CACHE_AGE);\n    \n    return searchAge > maxAge;\n  }\n\n  /**\n   * Save flight search data to LocalForage\n   */\n  async saveFlightData(searchParams: FlightSearchData['searchParams'], searchResults: any, timing: any, selectedOfferId?: string, userProgress?: FlightSearchData['userProgress']): Promise<string> {\n    const searchId = this.generateSearchId(searchParams);\n    const searchData: FlightSearchData = {\n      searchParams,\n      searchResults,\n      timing,\n      searchTimestamp: Date.now(),\n      selectedOfferId,\n      userProgress: userProgress || { currentStep: 'search' },\n      searchId\n    };\n\n    try {\n      // Clean up old cache entries before saving\n      await this.cleanupCache();\n      \n      // Save the data using LocalForage\n      await this.store.setItem(`${this.CACHE_PREFIX}${searchId}`, searchData);\n      console.log('Flight data saved to LocalForage with search ID:', searchId);\n      return searchId;\n    } catch (error) {\n      console.error('Error saving flight data to LocalForage:', error);\n      \n      // If still having issues, try aggressive cleanup\n      try {\n        await this.aggressiveCleanup();\n        await this.store.setItem(`${this.CACHE_PREFIX}${searchId}`, searchData);\n        console.log('Flight data saved after aggressive cleanup with search ID:', searchId);\n        return searchId;\n      } catch (retryError) {\n        console.error('Still cannot save after cleanup:', retryError);\n        return searchId;\n      }\n    }\n  }\n\n  /**\n   * Load flight search data from LocalForage by search ID\n   */\n  async loadFlightDataBySearchId(searchId: string): Promise<FlightSearchData | null> {\n    try {\n      const cached = await this.store.getItem(`${this.CACHE_PREFIX}${searchId}`);\n      if (!cached) return null;\n\n      const searchData: FlightSearchData = cached as FlightSearchData;\n      \n      // Check if offers are expired\n      if (this.isOffersExpired(searchData.timing)) {\n        console.log('Offers expired, removing from cache:', searchId);\n        await this.removeFlightDataBySearchId(searchId);\n        return null;\n      }\n\n      // Check if search data is stale\n      if (this.isSearchDataStale(searchData)) {\n        console.log('Search data is stale, marking for refresh:', searchId);\n        searchData.needsRefresh = true;\n      }\n\n      return searchData;\n    } catch (error) {\n      console.error('Error loading flight data from LocalForage:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Load flight search data from LocalForage by search parameters\n   */\n  async loadFlightData(searchParams: FlightSearchData['searchParams']): Promise<FlightSearchData | null> {\n    const searchId = this.generateSearchId(searchParams);\n    return await this.loadFlightDataBySearchId(searchId);\n  }\n\n  /**\n   * Update user progress in cached data\n   */\n  async updateUserProgress(searchParams: FlightSearchData['searchParams'], progress: Partial<FlightSearchData['userProgress']>): Promise<void> {\n    const searchId = this.generateSearchId(searchParams);\n    const searchData = await this.loadFlightDataBySearchId(searchId);\n    if (!searchData) return;\n\n    searchData.userProgress = { ...searchData.userProgress, ...progress };\n    await this.saveFlightData(\n      searchData.searchParams,\n      searchData.searchResults,\n      searchData.timing,\n      searchData.selectedOfferId,\n      searchData.userProgress\n    );\n  }\n\n  /**\n   * Update selected offer in cached data\n   */\n  async updateSelectedOffer(searchParams: FlightSearchData['searchParams'], offerId: string): Promise<void> {\n    const searchId = this.generateSearchId(searchParams);\n    const searchData = await this.loadFlightDataBySearchId(searchId);\n    if (!searchData) return;\n\n    searchData.selectedOfferId = offerId;\n    await this.saveFlightData(\n      searchData.searchParams,\n      searchData.searchResults,\n      searchData.timing,\n      offerId,\n      searchData.userProgress\n    );\n  }\n\n  /**\n   * Remove flight data from cache by search ID\n   */\n  async removeFlightDataBySearchId(searchId: string): Promise<void> {\n    try {\n      await this.store.removeItem(`${this.CACHE_PREFIX}${searchId}`);\n      console.log('Flight data removed from LocalForage:', searchId);\n    } catch (error) {\n      console.error('Error removing flight data from LocalForage:', error);\n    }\n  }\n\n  /**\n   * Remove flight data from cache\n   */\n  async removeFlightData(searchParams: FlightSearchData['searchParams']): Promise<void> {\n    const searchId = this.generateSearchId(searchParams);\n    await this.removeFlightDataBySearchId(searchId);\n  }\n\n  /**\n   * Get all cached flight searches\n   */\n  async getAllCachedSearches(): Promise<FlightDataCache> {\n    const cache: FlightDataCache = {};\n    \n    try {\n      const keys = await this.store.keys();\n      for (const key of keys) {\n        if (key.startsWith(this.CACHE_PREFIX)) {\n          const cached = await this.store.getItem(key);\n          if (cached) {\n            const searchData: FlightSearchData = cached as FlightSearchData;\n            const searchId = key.replace(this.CACHE_PREFIX, '');\n            cache[searchId] = searchData;\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error getting cached searches:', error);\n    }\n\n    return cache;\n  }\n\n  /**\n   * Clean up expired and stale cache entries\n   */\n  async cleanupCache(): Promise<void> {\n    const cachedSearches = await this.getAllCachedSearches();\n    \n    for (const [searchId, searchData] of Object.entries(cachedSearches)) {\n      const isExpired = this.isOffersExpired(searchData.timing);\n      const isStale = this.isSearchDataStale(searchData);\n      \n      if (isExpired || isStale) {\n        await this.removeFlightDataBySearchId(searchId);\n        console.log('Cleaned up expired/stale cache entry:', searchId);\n      }\n    }\n  }\n\n  /**\n   * Aggressive cleanup to free up storage space\n   */\n  async aggressiveCleanup(): Promise<void> {\n    const cachedSearches = await this.getAllCachedSearches();\n    \n    // Sort by timestamp (oldest first)\n    const sortedSearches = Object.entries(cachedSearches)\n      .sort(([, a], [, b]) => a.searchTimestamp - b.searchTimestamp);\n    \n    // Keep only the 5 most recent searches\n    const searchesToKeep = sortedSearches.slice(-5);\n    const searchesToRemove = sortedSearches.slice(0, -5);\n    \n    for (const [searchId] of searchesToRemove) {\n      await this.removeFlightDataBySearchId(searchId);\n      console.log('Aggressively cleaned up cache entry:', searchId);\n    }\n    \n    console.log(`Aggressive cleanup: Kept ${searchesToKeep.length} recent searches, removed ${searchesToRemove.length} old searches`);\n  }\n\n  /**\n   * Check localStorage usage and log statistics\n   */\n  async logStorageStats(): Promise<void> {\n    try {\n      const cachedSearches = await this.getAllCachedSearches();\n      const totalKeys = Object.keys(cachedSearches).length;\n      \n      let totalSize = 0;\n      for (const [searchId, searchData] of Object.entries(cachedSearches)) {\n        const size = JSON.stringify(searchData).length;\n        totalSize += size;\n        console.log(`Search ${searchId}: ${size} bytes`);\n      }\n      \n      console.log(`Storage stats: ${totalKeys} searches, ${totalSize} total bytes`);\n      console.log(`Current driver: ${this.store.driver()}`);\n      \n      // Test storage capacity\n      try {\n        await this.store.setItem('test_quota_check', 'test');\n        await this.store.removeItem('test_quota_check');\n        console.log('LocalForage quota check: OK');\n      } catch (error) {\n        console.error('LocalForage quota check: FAILED', error);\n      }\n    } catch (error) {\n      console.error('Error checking storage stats:', error);\n    }\n  }\n\n  /**\n   * Check if data needs refresh (expired or stale)\n   */\n  async needsRefresh(searchParams: FlightSearchData['searchParams']): Promise<{ needsRefresh: boolean; reason: 'expired' | 'stale' | null }> {\n    const searchData = await this.loadFlightData(searchParams);\n    if (!searchData) {\n      return { needsRefresh: true, reason: null };\n    }\n\n    if (this.isOffersExpired(searchData.timing)) {\n      return { needsRefresh: true, reason: 'expired' };\n    }\n\n    if (this.isSearchDataStale(searchData)) {\n      return { needsRefresh: true, reason: 'stale' };\n    }\n\n    return { needsRefresh: false, reason: null };\n  }\n\n  /**\n   * Get time remaining until offers expire\n   */\n  async getTimeRemaining(searchParams: FlightSearchData['searchParams']): Promise<number> {\n    const searchData = await this.loadFlightData(searchParams);\n    if (!searchData || !searchData.timing.expires_at) return 0;\n\n    const now = new Date().getTime();\n    const expiryTime = new Date(searchData.timing.expires_at).getTime();\n    return Math.max(0, expiryTime - now);\n  }\n\n  /**\n   * Format time remaining as MM:SS\n   */\n  formatTimeRemaining(milliseconds: number): string {\n    if (milliseconds <= 0) return '00:00';\n    \n    const totalSeconds = Math.floor(milliseconds / 1000);\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = totalSeconds % 60;\n    \n    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n  }\n}\n\n// Export singleton instance\nexport const flightDataPersistence = new FlightDataPersistence(); "],"names":["flightDataPersistence","CACHE_PREFIX","MAX_CACHE_AGE","OFFER_EXPIRY_BUFFER","SUPPLIER_TIMEOUT_MULTIPLIER","store","constructor","this","localforage","createInstance","name","storeName","description","setDriver","INDEXEDDB","WEBSQL","LOCALSTORAGE","generateSearchId","searchParams","origin","destination","departureDate","returnDate","passengers","cabinClass","currency","maxConnections","btoa","replace","substring","createSearchUrl","language","searchId","params","URLSearchParams","toString","append","createFlightDetailsUrl","offerId","extractSearchParamsFromUrl","url","URL","window","location","get","parseInt","error","getSearchIdFromUrl","isOffersExpired","timing","expires_at","Date","getTime","isSearchDataStale","searchData","searchAge","now","searchTimestamp","supplierTimeout","supplier_timeout","Math","max","saveFlightData","searchResults","selectedOfferId","userProgress","currentStep","cleanupCache","setItem","aggressiveCleanup","retryError","loadFlightDataBySearchId","cached","getItem","removeFlightDataBySearchId","needsRefresh","loadFlightData","updateUserProgress","progress","updateSelectedOffer","removeItem","removeFlightData","getAllCachedSearches","cache","keys","key","startsWith","cachedSearches","Object","entries","isExpired","isStale","sortedSearches","sort","a","b","searchesToRemove","slice","logStorageStats","length","totalSize","JSON","stringify","reason","getTimeRemaining","expiryTime","formatTimeRemaining","milliseconds","totalSeconds","floor","seconds","padStart"],"mappings":"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"}