{"version":3,"file":"utils-mapboxutils.ts.6FvsIj9k.js","sources":["../../../../src/utils/mapboxUtils.ts"],"sourcesContent":["import { supabase } from '@/integrations/supabase/client';\n\nlet cachedToken: string | null = null;\nlet tokenPromise: Promise<string> | null = null;\n\n/**\n * Get Mapbox access token securely from Supabase function\n * Uses caching to avoid repeated API calls\n * Falls back to environment variable if Edge Function fails\n */\nexport const getMapboxToken = async (): Promise<string> => {\n  // Return cached token if available\n  if (cachedToken) {\n    return cachedToken;\n  }\n\n  // Return existing promise if a request is already in progress\n  if (tokenPromise) {\n    return tokenPromise;\n  }\n\n  // Create new promise to fetch token\n  tokenPromise = (async () => {\n    try {\n      // Try to get token from Supabase Edge Function first\n      const { data, error } = await supabase.functions.invoke('get-mapbox-key');\n      if (error) {\n        console.warn('Supabase Edge Function failed, trying fallback:', error.message);\n        throw error;\n      }\n      if (!data?.key) {\n        throw new Error('No Mapbox token received from server');\n      }\n      \n      cachedToken = data.key;\n      return data.key;\n    } catch (err) {\n      console.warn('Failed to fetch Mapbox token from Edge Function, using fallback:', err);\n      \n      // Fallback to environment variable (for development or if Edge Function is not deployed)\n      const fallbackToken = import.meta.env.VITE_MAPBOX_TOKEN || process.env.VITE_MAPBOX_TOKEN;\n      if (fallbackToken) {\n        console.warn('Using fallback Mapbox token from environment variable');\n        cachedToken = fallbackToken;\n        return fallbackToken;\n      }\n      \n      // If no fallback is available, throw a more helpful error\n      throw new Error('Mapbox token not available. Please check your environment configuration.');\n    } finally {\n      tokenPromise = null;\n    }\n  })();\n\n  return tokenPromise;\n};\n\n/**\n * Make a Mapbox API call with secure token\n */\nexport const makeMapboxApiCall = async (endpoint: string, params: Record<string, string> = {}): Promise<any> => {\n  const token = await getMapboxToken();\n  const url = new URL(endpoint);\n  \n  // Add access token\n  url.searchParams.set('access_token', token);\n  \n  // Add other parameters\n  Object.entries(params).forEach(([key, value]) => {\n    url.searchParams.set(key, value);\n  });\n\n  const response = await fetch(url.toString());\n  if (!response.ok) {\n    throw new Error(`Mapbox API error: ${response.statusText}`);\n  }\n\n  return response.json();\n};\n\n/**\n * Geocode coordinates to location name\n */\nexport const reverseGeocode = async (longitude: number, latitude: number, types: string = 'place'): Promise<any> => {\n  const query = `${longitude},${latitude}`;\n  const url = new URL(`https://api.mapbox.com/geocoding/v5/mapbox.places/${query}.json`);\n  \n  // Add access token\n  const token = await getMapboxToken();\n  url.searchParams.set('access_token', token);\n  \n  // Add other parameters\n  url.searchParams.set('types', types);\n  url.searchParams.set('limit', '1');\n\n  const response = await fetch(url.toString());\n  if (!response.ok) {\n    throw new Error(`Mapbox API error: ${response.statusText}`);\n  }\n\n  return response.json();\n};\n\n/**\n * Geocode location name to coordinates\n */\nexport const geocode = async (query: string, types: string = 'place,address,poi'): Promise<any> => {\n  const encodedQuery = encodeURIComponent(query);\n  const url = new URL(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodedQuery}.json`);\n  \n  // Add access token\n  const token = await getMapboxToken();\n  url.searchParams.set('access_token', token);\n  \n  // Add other parameters\n  url.searchParams.set('types', types);\n  url.searchParams.set('limit', '15');\n\n  const response = await fetch(url.toString());\n  if (!response.ok) {\n    throw new Error(`Mapbox API error: ${response.statusText}`);\n  }\n\n  return response.json();\n};\n\n/**\n * Generate static map URL with secure token\n */\nexport const generateStaticMapUrl = async (\n  coordinates: [number, number],\n  zoom: number = 12,\n  width: number = 400,\n  height: number = 300,\n  style: string = 'mapbox://styles/mapbox/streets-v11',\n  marker?: string\n): Promise<string> => {\n  const token = await getMapboxToken();\n  const [lng, lat] = coordinates;\n  \n  // Parse the style URL to extract the style ID\n  // Expected format: mapbox://styles/mapbox/streets-v11\n  const styleMatch = style.match(/mapbox:\\/\\/styles\\/mapbox\\/(.+)/);\n  const styleId = styleMatch ? styleMatch[1] : 'streets-v11';\n  \n  let url = `https://api.mapbox.com/styles/v1/mapbox/${styleId}/static/`;\n  \n  if (marker) {\n    url += `${marker}/`;\n  }\n  \n  url += `${lng},${lat},${zoom}/${width}x${height}@2x?access_token=${token}`;\n  \n  return url;\n};\n\n/**\n * Clear cached token (useful for testing or token refresh)\n */\nexport const clearMapboxTokenCache = () => {\n  cachedToken = null;\n  tokenPromise = null;\n}; "],"names":["cachedToken","tokenPromise","getMapboxToken","async","data","error","supabase","functions","invoke","key","Error","err","fallbackToken","define_process_env_default","VITE_MAPBOX_TOKEN","generateStaticMapUrl","coordinates","zoom","width","height","style","marker","token","lng","lat","styleMatch","match","url"],"mappings":"wEAEA,IAAIA,EAA6B,KAC7BC,EAAuC,KAOpC,MAAMC,EAAiBC,SAExBH,IAKAC,IAKJA,EAAA,WACM,IAEI,MAAAG,KAAEA,QAAMC,SAAgBC,EAASC,UAAUC,OAAO,kBACxD,GAAIH,EAEI,MAAAA,EAEJ,IAACD,GAAMK,IACH,MAAA,IAAIC,MAAM,wCAIlB,OADAV,EAAcI,EAAKK,IACZL,EAAKK,UACLE,GAID,MAAAC,EAAqDC,EAAYC,kBACvE,GAAIF,EAGK,OADOZ,EAAAY,EACPA,EAIH,MAAA,IAAIF,MAAM,2EAA0E,CAC1F,QACeT,EAAA,IAAA,CAEhB,EA9BH,GAgCOA,IA2EIc,EAAuBZ,MAClCa,EACAC,EAAe,GACfC,EAAgB,IAChBC,EAAiB,IACjBC,EAAgB,qCAChBC,KAEM,MAAAC,QAAcpB,KACbqB,EAAKC,GAAOR,EAIbS,EAAaL,EAAMM,MAAM,mCAG3B,IAAAC,EAAM,2CAFMF,EAAaA,EAAW,GAAK,wBAUtC,OANHJ,IACFM,GAAO,GAAGN,MAGLM,GAAA,GAAGJ,KAAOC,KAAOP,KAAQC,KAASC,qBAA0BG,IAE5DK,CAAA"}